%\documentclass[usenames,dvipsnames,12pt,handout]{beamer}
\documentclass[usenames,dvipsnames,12pt]{beamer}

\usecolortheme{dove}
\usefonttheme{professionalfonts}
\usefonttheme{serif}

\usepackage{bm}
\usepackage{mathtools}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{mathrsfs}
\usepackage{mathabx}
\usepackage{fontspec}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{pifont}
\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{graphicx}
\usepackage{semantic}
\usepackage{xspace}
\usepackage[all]{xy}
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{fancybox}
\usepackage{stmaryrd}
\usepackage{rotating}
\usepackage{wasysym}
\usepackage{ulem}
\usepackage{soul}
\usepackage{newunicodechar}
\usepackage[super]{nth}
\usepackage{tikz, tikz-qtree, tikz-qtree-compat}
\usetikzlibrary{shapes, arrows, calc, quotes, tikzmark, decorations.pathreplacing, decorations.markings}
\usepackage{makecell}
\usepackage{epigraph}

\setlength{\multicolsep}{3pt}
\setlength{\columnseprule}{0.5pt}

\newcommand\mytikzmark[2]{\tikz[overlay,remember picture, anchor=base] \node (#1) {#2};}

% colored underline, with Beamer overlay support
% usage: \cul{x} or \cul[blue]{x} or \cul<2->{x} or \cul<2->[blue]{x}
\newcommand<>{\cul}[2][Red]{
  \fontdimen8\textfont3=0.75pt
  \alt#3
      {\color{#1}\underline{{\color{black}#2}}\color{black}}
      {\transparent{0.0}\underline{{\transparent{1.0}#2}}\transparent{1.0}}
}
\newcommand{\smalltt}[1]{{\small \texttt{#1}}}
\newcommand{\McL}{\mathscr{L}}
\newcommand{\yes}{\textcolor{Green}{\ding{51}}}
\newcommand{\no}{\textcolor{Red}{\ding{55}}}
\newcommand{\maybe}{\ding{82}}
\newcommand{\redtext}[1]{\textcolor{Maroon}{#1}}
\newcommand{\bluetext}[1]{\textcolor{NavyBlue}{#1}}
\newcommand{\orangetext}[1]{\textcolor{BurntOrange}{#1}}
\newcommand{\greentext}[1]{\textcolor{PineGreen}{#1}}
\newcommand{\graytext}[1]{\textcolor{gray}{#1}}
\newcommand{\purpletext}[1]{\textcolor{Plum}{#1}}
\newcommand{\bl}[1]{\ensuremath{\orangetext{#1}}}
\newcommand{\key}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\MID}{\;\mid\;}
\newcommand{\Surface}{\ensuremath{\lambda_{\mathtt{IFC}}^\star}\xspace}
\newcommand{\SurfaceOld}{\ensuremath{\lambda_{\mathtt{SEC}}^\star}\xspace}
\newcommand{\CCOld}{\ensuremath{\lambda_{\mathtt{SEC}}^{\Rightarrow}}\xspace}
\newcommand{\CC}{\ensuremath{\lambda_{\mathtt{IFC}}^{c}}\xspace}
\newcommand{\GSLRef}{\ensuremath{\mathrm{GSL}_\mathsf{Ref}}\xspace}
\newcommand{\GSLRefEps}{\ensuremath{\mathrm{GSL}_\mathsf{Ref}^\epsilon}\xspace}
\newcommand{\SSLRef}{\ensuremath{\mathrm{SSL}_\mathsf{Ref}}\xspace}
\newcommand{\lamgif}{\ensuremath{\mathit{\lambda_{gif}}}\xspace}
\newcommand{\WHILEG}{WHILE\textsuperscript{G}\xspace}
\newcommand{\high}{\textcolor{OrangeRed}{\key{high}}\xspace}
\newcommand{\low}{\textcolor{PineGreen}{\key{low}}\xspace}
\newcommand{\unk}{\textcolor{Maroon}{\key{\star}}\xspace}
\newcommand{\Bool}{\key{Bool}}
\newcommand{\Int}{\key{Int}}
\newcommand{\Unit}{\key{Unit}}
\newcommand{\Fun}[3]{\ensuremath{{#1}\xrightarrow{{#2}}{#3}}}
\newcommand{\Refer}[1]{\ensuremath{\key{Ref}\;{#1}}}
\newcommand{\true}{\key{true}}
\newcommand{\false}{\key{false}}
\newcommand{\unit}{\key{unit}}
\newcommand{\pc}{\ensuremath{\mathit{pc}}\xspace}
\newcommand{\PC}{\ensuremath{\mathit{PC}}\xspace}
\newcommand{\gc}{\ensuremath{\mathit{gc}}\xspace}
\newcommand{\syntax}[1]{\text{\texttt{\textcolor{Purple}{#1}}}}
\newcommand{\ccsyntax}[1]{\text{\texttt{{#1}}}}
\newcommand{\const}[2]{\ensuremath{\syntax{(\$}\;{#1}\syntax{)}_{#2}}}
\newcommand{\lam}[5]{\ensuremath{\syntax{(Œª}^{#1}{#2}\syntax{:}{#3}\syntax{.}\,{#4}\syntax{)}_{#5}}}
\newcommand{\app}[3]{\ensuremath{\syntax{(}{#1}\;{#2}\syntax{)}^{\bl{#3}}}}
\newcommand{\ifexp}[4]{\ensuremath{\syntax{(if}\;{#1}\;\syntax{then}\;{#2}\;\syntax{else}\;{#3}\syntax{)}^{\bl{#4}}}}
\newcommand{\refexp}[3]{\ensuremath{\syntax{(ref}\;{#1}\;{#2}\syntax{)}^{\bl{#3}}}}
\newcommand{\deref}[1]{\ensuremath{\syntax{!}\;{#1}}}
\newcommand{\assign}[3]{\ensuremath{\syntax{(}{#1}\;\syntax{:=}\;{#2}\syntax{)}^{\bl{#3}}}}
\newcommand{\ann}[3]{\ensuremath{\syntax{(}{#1}\;\syntax{:}\;{#2}\syntax{)}^{\bl{#3}}}}
\newcommand{\letexp}[3]{\ensuremath{\syntax{let}\;{#1}={#2}\;\syntax{in}\;{#3}}}
\newcommand{\ccconst}[1]{\ensuremath{\ccsyntax{\$}\;{#1}}}
\newcommand{\ccaddr}[1]{\ensuremath{\ccsyntax{addr}\;{#1}}}
\newcommand{\cclam}[2]{\ensuremath{\ccsyntax{Œª}{#1}\ccsyntax{.}\,{#2}}}
\newcommand{\ccif}[5]{\ensuremath{\ccsyntax{if}\;{#1}\;{#2}\;{#3}\;{#4}\;{#5}}}
\newcommand{\ccifstar}[4]{\ensuremath{\ccsyntax{if}{\star}\,{#1}\,{#2}\,{#3}\,{#4}}}
\newcommand{\ccref}[2]{\ensuremath{\ccsyntax{ref}\;{#1}\;{#2}}}
\newcommand{\ccrefproj}[3]{\ensuremath{\ccsyntax{ref?}^{\bl{#3}}\;{#1}\;{#2}}}
\newcommand{\ccderef}[3]{\ensuremath{\ccsyntax{!}\;{#1}\;{#2}\;{#3}}}
\newcommand{\ccderefstar}[2]{\ensuremath{\ccsyntax{!}{\star}\,{#1}\,{#2}}}
\newcommand{\ccassign}[5]{\ensuremath{\ccsyntax{assign}\;{#1}\;{#2}\;{#3}\;{#4}\;{#5}}}
\newcommand{\ccassignproj}[5]{\ensuremath{\ccsyntax{assign?}^{\bl{#5}}\;{#1}\;{#2}\;{#3}\;{#4}}}
\newcommand{\cccast}[2]{\ensuremath{{#1}\,\ccsyntax{‚ü®}\,{#2}\,\ccsyntax{‚ü©}}}
\newcommand{\ccprot}[4]{\ensuremath{\ccsyntax{prot}\;{#1}\;{#2}\;{#3}\;{#4}}}
\newcommand{\cccastpc}[2]{\ensuremath{\ccsyntax{cast}_{\ccsyntax{pc}}\;{#1}\;{#2}}}
\newcommand{\cclet}[4]{\ensuremath{\ccsyntax{let}\;{#1}\ccsyntax{=}{#2}\ccsyntax{:}{#3}\;\ccsyntax{in}\;{#4}}}
\newcommand{\ccapp}[5]{\ensuremath{\ccsyntax{app}\;{#1}\;{#2}\;{#3}\;{#4}\;{#5}}}
\newcommand{\ccappstar}[4]{\ensuremath{\ccsyntax{app}{\star}\,{#1}\,{#2}\,{#3}\,{#4}}}
\newcommand{\ccopaque}{\ensuremath{\ccsyntax{‚óè}}}
\newcommand{\lconsisjoin}{\ensuremath{\,\widetilde{\curlyvee}\,}}  % label consistent join
\newcommand{\consisjoin}{\ensuremath{\,\widetilde{\vee}\,}}        % type consistent join
\newcommand{\lconsismeet}{\ensuremath{\,\widetilde{\curlywedge}\,}}  % label consistent meet
\newcommand{\consismeet}{\ensuremath{\,\widetilde{\wedge}\,}}        % type consistent meet
\newcommand{\Cast}[3]{\ensuremath{{#1}\Rightarrow^{\bl{#3}}{#2}}}
\newcommand{\Type}{\textit{Type}}
\newcommand{\RawType}{\textit{RawType}}
\newcommand{\Label}{\textit{Label}}
\newcommand{\compile}[1]{\ensuremath{\mathcal{C}\;{#1}}}
\newcommand{\applycast}[3]{\ensuremath{\mathbf{Cast}\;{#1}\,,\,{#2}\leadsto{#3}}}
\newcommand{\blame}[1]{\ensuremath{\key{blame}\;\bl{#1}}}
\newcommand{\reduce}[5]{\ensuremath{{#1}\mid{#2}\mid{#3}\longrightarrow{#4}\mid{#5}}}
\newcommand{\Active}[1]{\ensuremath{\mathbf{Active}\;{#1}}}
\newcommand{\Inert}[1]{\ensuremath{\mathbf{Inert}\;{#1}}}
\newcommand{\bigstep}[5]{\ensuremath{{#1}\mid{#2}\vdash{#3}\Downarrow{#4}\mid{#5}}}
\newcommand{\bigstepe}[5]{\ensuremath{{#1}\mid{#2}\vdash{#3}\Downarrow_\epsilon{#4}\mid{#5}}}
%% coercions
\newcommand{\id}[1]{\ensuremath{\mathit{\bold{id}}(#1)}}
\newcommand{\up}{\ensuremath{\boldsymbol{\uparrow}}}
\newcommand{\inj}[1]{\ensuremath{{#1}\,\boldsymbol{!}}}
\newcommand{\seq}{\ensuremath{\,\boldsymbol{;}\,}}
\newcommand{\err}[3]{\ensuremath{\boldsymbol{\bot}^{\bl{#3}}\;{#1}\;{#2}}}
\newcommand{\proj}[2]{\ensuremath{{#1}\,\boldsymbol{?}^{\bl{#2}}}}
\newcommand{\coerc}[2]{\ensuremath{{#1}\boldsymbol{,}\,{#2}}}
\newcommand{\refco}[2]{\ensuremath{\mathbf{Ref}\;{#1}\;{#2}}}
\newcommand{\funco}[3]{\ensuremath{{#1}\boldsymbol{,}\,{#2}\boldsymbol{\rightarrow}{#3}}}
\newcommand{\precctx}[8]{\ensuremath{{#1};{#2};{#3};{#4};{#5};{#6};{#7};{#8}}}
\newcommand{\ccprec}[4]{\ensuremath{\vdash{#1}\sqsubseteq{#2}\Leftarrow{#3}\sqsubseteq{#4}}}

\newcommand{\highlight}[2]{\colorbox{#1}{\ensuremath{#2}}}
\newcommand{\highlightblue}[1]{\highlight{White!90!NavyBlue}{#1}}
\newcommand{\highlightred}[1]{\highlight{White!90!Maroon}{#1}}

\definecolor{highlight}{gray}{0.9}

\newunicodechar{‚Ñí}{\ensuremath{\McL}}
\newunicodechar{ùïã}{\ensuremath{\mathbb{T}}}
\newunicodechar{ùïä}{\ensuremath{\mathbb{S}}}

\newtheorem{conjecture}[theorem]{\translate{Conjecture}}
%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{constraint}[theorem]{Constraint}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{example}[theorem]{Example}

%% Configurations:
\setmainfont{EB Garamond}
\setmonofont[Scale=0.9]{Iosevka}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}[frame number]
\setbeamerfont{footnote}{size=\tiny}
\setlength{\multicolsep}{3pt}
\setbeamertemplate{itemize item}{$\blacktriangleright$}
\setbeamertemplate{itemize subitem}{$\circ$}
\setbeamertemplate{itemize/enumerate subbody begin}{\footnotesize}

\lstdefinestyle{mystyle}{
  commentstyle=\color{Green},
  keywordstyle=\color{Magenta},
  numberstyle=\tiny\color{Gray},
  stringstyle=\color{Purple},
  basicstyle=\ttfamily\small,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}

\lstset{style=mystyle}

\setlength{\epigraphwidth}{\textwidth}


\title{The Holy Grail of Gradual Security \\
  {\small\textcolor{NavyBlue}{Ph.D Thesis Proposal Presentation}} \vspace{-15pt}}
\author{Tianyu Chen}
\institute{\small Computer Science, Indiana University}
\date{}

\begin{document}

%%%%%%%%%% Cover Page %%%%%%%%%%%
\begin{frame}
  \titlepage
  \begin{tikzpicture}[remember picture,overlay]
    \node [anchor=north east] at ([xshift=-15pt, yshift=5pt]current page.north east)
          {\includegraphics[height=30pt]{iu_tab_web}};
  \end{tikzpicture}

  \vspace{-45pt}

  \begin{center}
    \includegraphics[width=4in]{acanthus}
  \end{center}

  \footnotetext{Acanthus textiles. William Morris Gallery}
\end{frame}

%%%%%%%%%% Road Map %%%%%%%%%%%
\begin{frame}
  \frametitle{Road Map}

  \begin{itemize}
  \item[\textcolor{Red}{\ding{43}}] \cul{Background:}
    \begin{itemize}
    \item Explicit flow and implicit flow
    \item Information flow control (IFC), static and dynamic
    \item The tension between IFC and gradual typing
    \end{itemize}
  \item \Surface in Action
    \begin{itemize}
    \item[\ding{79}] Solving the Tension Between Noninterference and the Gradual Guarantee
    \item Type-Based Reasoning in \Surface
    \end{itemize}
  \item Coercion-based Semantics for Gradual Security
  \item Meta-theoretical Results of \Surface
  \end{itemize}
\end{frame}

%%%%%%%%%% Explicit Information Flow %%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{Explicit Information Flow}

  Can we infer output from input in the following program?

\begin{verbatim}
let input = private-input () in publish (¬¨ input)
\end{verbatim}

\onslide<2-> {
  \begin{itemize}
  \item[\yes] Yes!
  \item Witness at least two executions
  \item Output is the negation of input
  \item \purpletext{Explicit flow}
  \end{itemize}
}

\end{frame}

%%%%%%%%%% Implicit Information Flow %%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{Implicit Information Flow}

  Can we infer output from input in the following program?
\begin{verbatim}
  let input = private-input () in
      publish (if input then false else true)
\end{verbatim}

\onslide<2-> {
\begin{itemize}
  \item[\yes] Also yes
  \item Again, output is the negation of input
  \item \purpletext{Implicit flow}: input influences output through {\large\textit{branching}}
\end{itemize}
}

\end{frame}

%%%%%%%%%% IFC %%%%%%%%%%%
\begin{frame}
  \frametitle{Information-Flow Control (IFC)}

  \begin{itemize}
  \item Ensures that information transfers adhere to a security policy
    \item For example, \high input must not flow to \low output
    \item Propagate and check the security labels
    \item IFC in PL
      \(
      \left\{
      \begin{minipage}[c]{0.75\linewidth}
      \item[] \bluetext{\Huge static} using a type system
      \item[] \redtext{\Huge dynamic} using runtime monitoring
      \end{minipage}
      \right.
      \)
  \end{itemize}
\end{frame}

%%%%%%%%%% Static IFC, Explicit Flow %%%%%%%%%%%
\begin{frame}[containsverbatim]
  \frametitle{\bluetext{Static IFC} Accepts \textcolor{Green}{Legal} Explicit Flow}

  (Static IFC using a type system)
  \begin{lstlisting}[mathescape,autogobble,xleftmargin=.15\textwidth,xrightmargin=.15\textwidth]
    let fconst = Œª b : $\Bool_{\high}$. false in
    let input  = private-input () in
    let result = fconst input in
      publish result
  \end{lstlisting}

  \begin{itemize}
  \item[\yes] \textcolor{Green}{Well-typed} \qquad~and~\qquad
    \yes \; \textcolor{Green}{Runs successfully} to \texttt{unit}
  \item Why? The return value of \texttt{fconst} is
    \(
    \left\{
    \begin{minipage}[c]{0.3\linewidth}
    \item[] always \texttt{false}
    \item[] of \low-security
    \end{minipage}
    \right.
    \)
  \item Accepted by type-checker. No runtime check
  \end{itemize}

  \footnotetext{\texttt{private-input : $\Unit_{\low}$ ‚Üí $\Bool_{\high}$}~and~\texttt{publish : $\Bool_{\low}$ ‚Üí $\Unit_{\low}$}}
\end{frame}


\begin{frame}[containsverbatim]
  \frametitle{\bluetext{Static IFC} Rejects \textcolor{Red}{Illegal} Explicit Flow}

  (Replace \texttt{fconst} with \texttt{flip})
  \begin{lstlisting}[mathescape,autogobble,xleftmargin=.1\textwidth]
    let flip   = Œª b : $\highlightblue{\Bool_{\low}}$. ¬¨ b in
    let input  = private-input () in
    let result = flip input in  $\graytext{\text{// compilation error}}$
      publish result
  \end{lstlisting}
  \vspace{15pt}

  \begin{itemize}
  \item[\no] \textcolor{Red}{Ill-typed.} Illegal explicit flow:
  \begin{itemize}
  \item input is \high
  \item \texttt{flip} expects \low argument
  \end{itemize}
  \item Rejected by type-checker. Again no runtime check
  \end{itemize}
\end{frame}

%%%%%%%%%% Dynamic IFC, Explicit Flow %%%%%%%%%%%
\begin{frame}[containsverbatim]
  \frametitle{\redtext{Dynamic} Enforcement of Explicit Flow}

  (Revisit \texttt{flip} with dynamic IFC)
  \begin{lstlisting}[mathescape,autogobble,xleftmargin=.15\textwidth,xrightmargin=.15\textwidth]
    let flip    = Œª b. ¬¨ b in
    let input   = private-input () in
    let result  = flip input in
      publish result    $\graytext{\text{// runtime error}}$
  \end{lstlisting}

  \begin{itemize}
  \item[\no] \textcolor{Red}{Fails} at runtime (regardless of input)
  \item \redtext{A runtime check} happens before calling \texttt{publish}
  \end{itemize}

  In dynamic IFC, runtime values are tagged with their security level. The
  labels can originate from
  \begin{itemize}
  \item primitive operations
  \item annotations on literals
  \item the security level of the execution context
  \end{itemize}

\end{frame}

%%%%%%%%%% Static IFC, Implicit Flow %%%%%%%%%%%
\begin{frame}[containsverbatim]
  \frametitle{\bluetext{Static} Enforcement of Implicit Flow}

  (Different behavior in different branches)
  \begin{lstlisting}[mathescape,autogobble,xleftmargin=.1\textwidth]
    let flip : $\Bool_{\high}$ ‚Üí $\highlightblue{\Bool_{\low}}$ =
        Œª b : $\Bool_{\high}$. $\highlightred{\text{if b then false else true}}$ in
    let input  = private-input () in
    let result = flip input in
      publish result
  \end{lstlisting}

  \begin{itemize}
  \item[\no] \textcolor{Red}{Ill-typed}
  \item Security label on the type of \texttt{if} is the join (least upper
    bound) of its branches (\low) and the branch condition (\high).
  \item Rejected by type-checker. No runtime check
  \end{itemize}

\end{frame}

%%%%%%%%%% Dynamic IFC, Implicit Flow %%%%%%%%%%%
\begin{frame}[containsverbatim]
  \frametitle{\redtext{Dynamic} Enforcement of Implicit Flow}

  (Enforcing implicit flow with dynamic IFC)
  \begin{lstlisting}[mathescape,autogobble,xleftmargin=20pt]
    let flip   = Œª b. if b then false else true in
    let input  = private-input () in
    let result = flip input in
      publish result
  \end{lstlisting}

  \begin{itemize}
  \item[\no] \textcolor{Red}{Fails} at runtime (regardless of input)
  \item \texttt{flip} produces a \high value because of \high branch condition
  \item A runtime check happens before calling \texttt{publish}
  \item Illegal implicit flow ruled out \redtext{at runtime}
  \end{itemize}

\end{frame}

%%%%%%%%%% Dynamic IFC, Implicit Flow %%%%%%%%%%%
\begin{frame}[containsverbatim]
  \frametitle{\purpletext{Gradual Typing} Bridges Static and Dynamic IFC}

  Partially-annotated \texttt{flip}:
  \begin{lstlisting}[mathescape,autogobble,xleftmargin=20pt]
    let flip : $\highlightred{\Bool_{\unk}}$ ‚Üí $\highlightblue{\Bool_{\low}}$ =
        Œª b : $\highlightred{\Bool_{\unk}}$. if b then false else true in
    let input  = private-input () in
    let result = flip input in
      publish result
  \end{lstlisting}

  \begin{itemize}
  \item \textcolor{Green}{Well-typed}\quad~but~\quad\textcolor{Red}{errors at runtime}
  \item Checking happens on the boundaries between static and dynamic fragments
  \item The information flow violation is detected earlier than the dynamic
    version, as \texttt{flip} returns
  \end{itemize}

\end{frame}

%%%%%%%%%% Gradual Guarantee %%%%%%%%%%%
\begin{frame}[containsverbatim]
  \frametitle{\purpletext{The Gradual Guarantee}}

  \begin{minipage}{0.3\textwidth}
    \redtext{\footnotesize less precise}
  \begin{lstlisting}[mathescape,autogobble,basicstyle=\tiny\ttfamily,numbers=none]
    let f : $\highlightred{\Bool_{\unk}}$‚Üí$\highlightred{\Bool_{\unk}}$ =
        Œª b : $\highlightred{\Bool_{\unk}}$. true in
    let i = private-input () in
    let result = f i in
      publish result
  \end{lstlisting}
  \end{minipage}
  {\tiny $\sqsubseteq~$}
  \begin{minipage}{0.3\textwidth}
    \phantom{middling precise}
  \begin{lstlisting}[mathescape,autogobble,basicstyle=\tiny\ttfamily,numbers=none]
      let f : $\highlightred{\Bool_{\unk}}$‚Üí$\highlightblue{\Bool_{\low}}$ =
          Œª b : $\highlightred{\Bool_{\unk}}$. true in
      let i = private-input () in
      let result = f i in
        publish result
  \end{lstlisting}
  \end{minipage}
  {\tiny $\sqsubseteq~$}
  \begin{minipage}{0.3\textwidth}
    \bluetext{\footnotesize more precise}
  \begin{lstlisting}[mathescape,autogobble,basicstyle=\tiny\ttfamily,numbers=none]
      let f : $\highlightblue{\Bool_{\high}}$‚Üí$\highlightblue{\Bool_{\low}}$ =
          Œª b : $\highlightblue{\Bool_{\high}}$. true in
      let i = private-input () in
      let result = f i in
        publish result
  \end{lstlisting}
  \end{minipage}

  \vspace{20pt}

  \begin{itemize}
  \item In the absense of errors, adding or removing security annotations does
    not change the result of the program
  \item Adding security annotations may trigger errors
  \item Removing security annotations may not trigger errors
  \end{itemize}
\end{frame}

%%%%%%%%%% Static IFC Through Heap %%%%%%%%%%%
\begin{frame}[containsverbatim]
  \frametitle{\bluetext{Static} Enforcement of Flows Through \\ Mutable References}

  \vspace{-15pt}
  \begin{lstlisting}[mathescape,autogobble,xleftmargin=.2\textwidth,xrightmargin=.1\textwidth]
    let a     = ref $\low$ true in
    let input = private_input () in
    if input then
        a := false
    else
        a := true
    publish (! a)
  \end{lstlisting}

  \begin{itemize}
  \item The reference has type $\Refer{(\Bool_{\low})}$. It points to a low memory location
  \item The type of the branch condition is $\Bool_{\high}$
  \item[\no] \st{Writing to low memory under a high branch condition}
  \end{itemize}

\end{frame}

%%%%%%%%%% Dynamic IFC Through Heap %%%%%%%%%%%
\begin{frame}[containsverbatim]
  \frametitle{\redtext{Dynamic} Enforcement of Flows Through \\ Mutable References}

  \vspace{-15pt}
  \begin{lstlisting}[mathescape,autogobble,xleftmargin=.2\textwidth,xrightmargin=.1\textwidth]
    let a     = ref $\low$ true in
    let input = private_input () in
    if input then
        a := false
    else
        a := true
    publish (! a)
  \end{lstlisting}

  The assignments fail at runtime because the no-sensitive-upgrade (NSU)
  mechanism \footnote{Austin and Flanagan. \textit{Efficient purely-dynamic information
  flow analysis.} PLAS 2009.}
  prevents writing to a \low security pointer in a \high security branch.

\end{frame}

%%%%%%%%%% Counterexample of GG %%%%%%%%%%%
\begin{frame}[containsverbatim]
  \frametitle{Counterexample of Gradual Guarantee in \GSLRef}

  \begin{multicols}{2}
    \noindent
    \redtext{less precise}
    \begin{lstlisting}[mathescape,autogobble,basicstyle=\footnotesize\ttfamily]
        let x = private-input () in
        let a = ref $\unk$ $\true_{\unk}$ in
        if x then (a := $\false_{\high}$)
             else ()
    \end{lstlisting}
    \columnbreak
    \bluetext{more precise}
    \begin{lstlisting}[mathescape,autogobble,numbers=none,basicstyle=\footnotesize\ttfamily]
      let x = private-input () in
      let a = ref $\high$ $\true_{\high}$ in
      if x then (a := $\false_{\high}$)
           else ()
    \end{lstlisting}
  \end{multicols}

  \begin{itemize}
  \item[\yes] The \bluetext{more precise} program (right) runs successfully
  \item[\no] But the \redtext{less precise} version (left) errors in \GSLRef\footnote{Toro, Garcia, Tanter.
  \textit{Type-Driven Gradual Security with References.} TOPLAS 2018.}
  \item The assignment fails because it is in a high-security branch and \GSLRef
    conservatively treats the reference's label ($\unk$) as if it were $\low$
  \end{itemize}

\end{frame}

%%%%%%%%%% No `Dyn` in Runtime Labels %%%%%%%%%%%
\begin{frame}[containsverbatim]
  \frametitle{But wait... \GSLRef allows $\unk$ labels on values?}

  The counterexample depends on labeling a reference with unknown security (\unk):
  \vspace{5pt}
  \begin{lstlisting}[mathescape,autogobble,xleftmargin=.2\textwidth,xrightmargin=.2\textwidth]
    let x = private-input () in
    let a = ref $\unk$ $\true_{\unk}$ in
    if x then (a := $\false_{\high}$)
         else ()
  \end{lstlisting}
  \vspace{5pt}

  \begin{itemize}
  \item Dynamic IFC languages don't use $\unk$ as a runtime
    security label.
  \item Gradual languages traditionally use $\unk$ for type
    checking, but not for categorizing runtime values.
  \item The inputs to an information flow system are the user's
    choices regarding what data is high or low security.
  \end{itemize}

\end{frame}

%%%%%%%%%% Sources of Tension %%%%%%%%%%%
\begin{frame}
  \frametitle{Sources of the Tension with the Gradual Guarantee}

\begin{table}[tbp]
  \scriptsize
  \centering
  \begin{tabularx}{\textwidth}{X|c|c|c|c|c}
  \hline
  \thead{Lang.} & \thead{Noninter-\\ference} & \thead{Gradual\\Guarantee} &
  \thead{Type-guided \\ classification} & \thead{NSU} & \thead{Runtime \\ security labels} \\
  \hline
  \GSLRef    & \mytikzmark{a}{\yes}  & \cellcolor{Red!10} \mytikzmark{b}{\no} & \yes  & \yes & $\{ \low, \high, \unk \}$ \\[1ex]
  \hline
  GLIO      & \yes & \cellcolor{Green!10} \mytikzmark{c}{\yes} & \mytikzmark{d}{\no}  & \yes & $\{ \low, \high \}$ \\[1ex]
  \hline
  \WHILEG & \yes & \cellcolor{Green!10} \mytikzmark{e}{\yes} & \yes   & \mytikzmark{f}{\no} & $\{ \low, \high, \unk \}$ \\[1ex]
  \hline
  \rowcolor{highlight}
  \purpletext{\Surface (ours)} & \yes & \cellcolor{Green!10} \mytikzmark{g}{\yes} & \yes & \yes & \mytikzmark{h}{$\{ \low, \high \}$} \\[1ex]
  \hline
  \end{tabularx}
\begin{tikzpicture}[overlay, remember picture, yshift=.25\baselineskip, shorten >=.5pt, shorten <=.5pt]
  \draw[dashed,thick] (a) to [bend right=15] (b);
  \draw[dashed,thick] (c) to [bend right=15] (d);
  \draw[dashed,thick] (e) to [bend right=10] (f);
  \draw[thick]        (g) to [bend right=8 ] (h);
\end{tikzpicture}
  \label{tab:cc-features}
\end{table}

Removing \unk from the runtime labels enables the gradual guarantee.

\end{frame}

%%%%%%%%%% Example in LambdaIFCStar %%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{\Surface Excludes \unk From Runtime Labels}

  \begin{multicols}{2}
    \noindent
    \redtext{less precise}
    \begin{lstlisting}[mathescape,autogobble,basicstyle=\footnotesize\ttfamily]
      let x = private-input () in
      let a : $\highlightred{(\Refer{\Bool_{\unk}})_{\unk}}$ =
          ref $\high$ $\true_{\high}$ in
      if x then (a := $\false_{\high}$)
           else ()
    \end{lstlisting}
    \columnbreak
    \bluetext{more precise}
    \begin{lstlisting}[mathescape,autogobble,numbers=none,basicstyle=\footnotesize\ttfamily]
      let x = private-input () in
      let a : $\highlightblue{(\Refer{\Bool_{\high}})_{\high}}$ =
          ref $\high$ $\true_{\high}$ in
      if x then (a := $\false_{\high}$)
           else ()
    \end{lstlisting}
  \end{multicols}

  \begin{itemize}

  \item[\yes] The \bluetext{more precise} program runs \textcolor{Green}{successfully} to \texttt{unit}
  \item[\yes] The \redtext{less precise} program also runs \textcolor{Green}{successfully} to \texttt{unit}
  \onslide<2-> {
  \item[\yes] \greentext{\Huge Problem solved!}
  }
  \end{itemize}

  \onslide<2> {
  \begin{tikzpicture}[remember picture,overlay]
    \node [anchor=south east] at ([xshift=-30pt, yshift=10pt]current page.south east)
          {\includegraphics[height=90pt]{yay}};
  \end{tikzpicture}
  }
\end{frame}

\begin{frame}
  \frametitle{Coercion Calculus for Security Labels}

  Syntax and typing for security coercions and
  coercion sequences:

  \vspace{-20pt}
  \begin{figure}[tbp]
  \raggedright
  \[
  \begin{array}{rcll}
    \text{specific security labels} & \ell & \in & \{ \low , \high \} \\
    \text{gradual security labels}  & g    & ::= & \unk \MID \ell \\
    \text{blame labels}         & \bl{p}, \bl{q}     &      & \\
    \text{security coercions}            & c, d     & ::=  & \id{g} \MID \up \MID \inj{\ell} \MID \proj{\ell}{p} \MID \bot^{\bl{p}} \\
    \text{coercion sequences} & \bar{c}, \bar{d} & ::=  & \id{g} \MID \err{g_1}{g_2}{p} \MID \bar{c} \seq c
  \end{array}
  \]
  \fbox{$\vdash c : g_1 \Rightarrow g_2$}
  \begin{gather*}
    \inference{}{\vdash \id{g} : g \Rightarrow g}
    \quad
    \inference{}
              {\vdash \,\up\, : \low \Rightarrow \high}
    \quad
    \inference{}
              {\vdash \inj{\ell} : \ell \Rightarrow \unk}
    \\[1ex]
    \inference{}
              {\vdash \proj{\ell}{p} : \unk \Rightarrow \ell}
    \quad
    \inference{}
              {\vdash \bot^{\bl{p}} : \high \Rightarrow \low}
  \end{gather*}
  \end{figure}
\end{frame}


\begin{frame}
  Reduction semantics and normal forms of the coercion calculus on security labels:

\begin{figure}[tbp]
  \footnotesize
\raggedright
  \fbox{$\mathbf{NF}\; \bar{c}$}
  \begin{gather*}
  \inference{}{\mathbf{NF}\; \id{g}}
  \quad
  \inference{}{\mathbf{NF}\; \id{\unk} \seq \proj{\ell}{p}}
  \quad
  \inference{\mathbf{NF}\; \bar{c}}{\mathbf{NF}\; \bar{c}\seq\inj{\ell}}
  \quad
  \inference{\mathbf{NF}\; \bar{c}}{\mathbf{NF}\; \bar{c}\seq\up}
  \end{gather*}
  \fbox{$c \mathrel{;} c \longrightarrow c$}
  \begin{gather*}
  \textit{?-id}~
  \inference{}
            {\inj{\ell} \seq \proj{\ell}{p} \longrightarrow \id{\ell}}
  \quad
  \textit{?-}\uparrow~
  \inference{}
            {\inj{\low} \seq \proj{\high}{p} \longrightarrow \;\;\up}
  \\[1ex]
  \textit{?-}\bot~
  \inference{}
            {\inj{\high} \seq \proj{\low}{p} \longrightarrow \bot^{\bl{p}}}
  \end{gather*}
  \fbox{$\bar{c} \longrightarrow \bar{d}$}
  \begin{gather*}
  \textit{id}~
  \inference{\mathbf{NF}\; \bar{c}}
            {\bar{c} \seq \id{g} \longrightarrow \bar{c}}
  \qquad
  \bot~
  \inference{\mathbf{NF}\; \bar{c} & \vdash \bar{c} : g_1 \Rightarrow g_2}
            {\bar{c} \seq \bot^{\bl{p}} \longrightarrow \err{g_1}{\low}{p} }
  \\[1ex]
  \xi\textit{-}\bot~
  \inference{\vdash c : g_2 \Rightarrow g_3}
    {\err{g_1}{g_2}{p} \seq c \longrightarrow \err{g_1}{g_3}{p}}
  \\[1ex]
  \xi_L~
  \inference{\bar{c} \longrightarrow \bar{d}}{\bar{c} \seq c \longrightarrow \bar{d} \seq c}
  \qquad
  \xi_R~
  \inference{\mathbf{NF}\; \bar{c} & c \seq d \longrightarrow c'}
            {\bar{c} \seq c \seq d \longrightarrow \bar{c}; c'}
  \end{gather*}
\end{figure}
\end{frame}

\begin{frame}
  \frametitle{(A Glimpse of) the Cast Calculus \CC}

  \begin{itemize}
    \item Representation of PC: label expressions
      {\small $e, \PC ::= \ell \MID \blame{p} \MID \cccast{e}{\bar{c}}$}
    \item Coercions on values of \CC:
      \vspace{-5pt}
      \[
      \footnotesize
      \begin{array}{rcll}
        \text{base types}               & \iota     & ::= & \Unit \MID \Bool \\
        \text{raw types}                & T, S      & ::= & \iota \MID \Fun{A}{gc}{B} \mid \Refer{(T_g)} \\
        \text{types}                    & A, B      & ::= & T_g \\
        \text{raw coercions}            & c_r, d_r  & ::=  & \id{\iota} \MID \refco{\bm{c}}{\bm{d}} \MID \left( \funco{\bar{d}}{\bm{c}}{\bm{d}} \right) \\
        \text{coercions}                & \bm{c}, \bm{d} & ::= & \coerc{c_r}{\bar{c}}
      \end{array}
      \]
    \item NSU checking: reducing label expressions
      \vspace{-5pt}
      {\scriptsize
      \begin{gather*}
      \inference{n \; \mathbf{FreshIn} \; \mu(\ell) & \highlightred{\cccast{\PC}{\unk \Rightarrow^{\bl{p}} \ell} \longrightarrow^{*} \PC'} }
                {\reduce{\ccrefproj{\ell}{V}{p}}{\mu}{\PC}{\ccaddr{n}}{(\mu , \ell \mapsto n \mapsto V)}}
      \\[1ex]
      \begin{split}
      \inference{\mathbf{NF}\;\bar{c} & \highlightred{\cccast{(\mathit{stamp!}\;\PC\;|\bar{c}|)}{\unk \Rightarrow^{\bl{p}} \hat{\ell}} \longrightarrow^{*} \PC'} & \cccast{V}{\bm{c}} \longrightarrow^{*} W}
                {\reduce{\ccassignproj{\left(\cccast{\ccaddr{n}}{\coerc{\refco{\bm{c}}{\bm{d}}}{\bar{c}}}\right)}{V}{T}{g}{p}}{\mu}{\PC}{\ccconst{\unit}}{[\hat{\ell} \mapsto n \mapsto W] \; \mu}} \\
      \vdash \bm{c} : T_g \Rightarrow S_{\hat{\ell}} , \vdash \bm{d} : S_{\hat{\ell}} \Rightarrow T_g
      \end{split}
      \end{gather*}
      }
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Road Map}

  \begin{itemize}
  \item \textcolor{gray}{Background}
  \item \textcolor{gray}{\Surface in Action}
  \item \textcolor{gray}{Coercion-based Semantics for Gradual Security}
  \item[\textcolor{Red}{\ding{43}}] \cul{Meta-theoretical Results of \Surface}
  \end{itemize}
\end{frame}


\begin{frame}
  \begin{theorem}[Compilation preserves types]
    \label{thm:compile-pres}
    If $\Gamma ; g \vdash M : A$, then $\Gamma ; \emptyset ; g ; \low \vdash \compile{M} : A$.
  \end{theorem}

  \begin{theorem}[Progress]
    \label{thm:progress}
    Suppose \PC is well-typed: $\vdash \PC \Leftarrow g$,
    $M$ is well-typed: $\emptyset ; \Sigma ; g ; | \PC | \vdash M \Leftarrow A$,
    and the heap $\mu$ is well-typed: $\Sigma \vdash \mu$. \\
    Then either (1) $M$ is a value or (2) $M$ is a blame
    or (3) $M$ can take a reduction step:
    $\reduce{M}{\mu}{\PC}{N}{\mu'}$ for some $N$ and $\mu'$.
  \end{theorem}

  \begin{theorem}[Preservation]
    \label{thm:preservation}
    Suppose \PC is well-typed:  $\vdash \PC \Leftarrow g$,
    $M$ is well-typed: $\emptyset ; \Sigma ; g ; |\PC| \vdash M \Leftarrow A$
    and the heap $\mu$ is well-typed: $\Sigma \vdash \mu$. \\
    If $\reduce{M}{\mu}{\PC}{N}{\mu'}$, there exists $\Sigma'$ s.t
    $\Sigma' \supseteq \Sigma$, $\emptyset ; \Sigma' ; g ; |\PC| \vdash N \Leftarrow A$,
    and $\Sigma' \vdash \mu'$.
  \end{theorem}
\end{frame}

\begin{frame}
  \begin{theorem}[The gradual guarantee]
    Suppose $M$, $M'$ are related by precision:
    $$\precctx{\emptyset}{\emptyset}{\emptyset}{\emptyset}{\low}{\low}{\low}{\low}\ccprec{M}{M'}{A}{A'}$$
    If $M'$ evaluations to a value:
    $$M'\mid\emptyset\mid\low \longrightarrow^{*} V'\mid\mu'$$
    there exists $V$ and $\mu$ s.t. $M$ evaluates to $V$:
    $$M\mid\emptyset\mid\low \longrightarrow^{*} V\mid\mu$$
    and the resulting values are related by precision for some $\Sigma$, $\Sigma'$:
    $$\precctx{\emptyset}{\emptyset}{\Sigma}{\Sigma'}{\low}{\low}{\low}{\low}\ccprec{V}{V'}{A}{A'}$$
  \end{theorem}
\end{frame}

\begin{frame}

  The noninterference of \Surface is conjectured by that of \SurfaceOld:
  \bigskip

  \Surface performs type-guided classification but \SurfaceOld does not,
  so the value that a \Surface program produces is at least as secure as
  the value produced by the same program in \SurfaceOld.
  \bigskip

  \begin{theorem}[Noninterference of \SurfaceOld]
    \label{thm:NI}
    If $M$ is well-typed
    $(x{:}\Bool_{\high}) ; \emptyset ; \low ; \low \vdash M : \Bool_{\low}$
    and
    \begin{equation*}
    \begin{split}
        \bigstep{\emptyset}{\low}{M [ x := (b_1)_{\high}]}{V_1}{\mu_1} \\
        \bigstep{\emptyset}{\low}{M [ x := (b_2)_{\high}]}{V_2}{\mu_2}
    \end{split}
    \end{equation*}
    then $V_1 = V_2$.
  \end{theorem}
\end{frame}

\begin{frame}
  \frametitle{Code and Data Availability}

  \purpletext{\large \url{https://github.com/Gradual-Typing/LambdaSecStar}}
  \bigskip

  \includegraphics[width=\textwidth]{repo_stats}
\end{frame}

\begin{frame}
  \frametitle{Main Takeaways}

  \begin{enumerate}
    \item It is possible to satisfy both noninterference and the gradual guarantee
      in a gradual security-typed language,
      provided that the security level of data remains specific at runtime
      \smallskip
    \item Gradual information flow can be represented as coercions. In particular,
      NSU checking is a special projection that casts PC to the security of the memory
      location to modify
      \smallskip
    \item The key to the semantics design of of a gradual security-typed language is
      identifying injections ($\inj{\ell}$) and projections ($\proj{\ell}{p}$)
  \end{enumerate}
\end{frame}

\begin{frame}
  \centering \Large
  \redtext{Thank you} \bluetext{for your attention!}
\end{frame}

\end{document}
