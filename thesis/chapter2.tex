\chapter{Gradual Information-Flow Control (IFC) in \Surface}
\label{ch:examples}

In this chapter, we first define the gradual IFC surface language \Surface, by
presenting its syntax and type system in Section~\ref{sec:surface-def}. After
that, we put \Surface into action. We present example programs to demonstrate
how \Surface enables a gradual, smooth transition between static and dynamic
IFC, while supporting type-based reasoning and satisfying the gradual guarantee.
We review the basics of gradual IFC using \Surface programs in
Section~\ref{sec:example1}. In Section~\ref{sec:example2}, we show that the
tension between security and the gradual guarantee can be achieved by removing
\unk from the runtime security labels. In Section~\ref{sec:example3}, we
demonstrate that \Surface enables the same type-based reasoning capabilities as
\GSLRef. To conclude this chapter, we discuss the static and the dynamic
extremes of \Surface in Section~\ref{sec:embedding}. \Surface enables the
continuum of IFC enforcement between the static and dynamic extremes that it
embeds.

\section{The Gradual IFC Language \Surface}
\label{sec:surface-def}

We present the syntax and its supporting definitions in
Section~\ref{sec:surface-syntax}. We explain the type system for \Surface in
Section~\ref{sec:surface-typing}. Finally, we discuss the semantics of \Surface
by defining the \texttt{eval} function in Section~\ref{sec:surface-semantics}.

\subsection{Syntax of \Surface}
\label{sec:surface-syntax}

\begin{figure}[tbp]
\raggedright
  {\small
  \[
  \begin{array}{rcll}
    \text{specific security labels} & \ell & \in & \{ \low , \high \} \\
    \text{security labels}  & g    & ::= & \unk \MID \ell \\
    \text{base types}               & \iota     & ::= & \Unit \MID \Bool \\
    \text{raw types}                & T, S      & ::= & \iota \MID \Fun{A}{\gc}{B} \mid \Refer{(T_g)} \\
    \text{blame labels}         & \bl{p}, \bl{q}     &      & \\
    \text{types}                    & A, B      & ::= & T_g \\
    \text{terms}                & L , M , N & ::=  & x \MID \const{k}{\text{\hl{$\ell$}}} \MID \lam{g}{x}{A}{N}{\text{\hl{$\ell$}}} \MID \app{L}{M}{p} \\
    &                                       & \MID & \ifexp{L}{M}{N}{p} \MID \letexp{x}{M}{N} \\
    &                                       & \MID & \refexp{\text{\hl{$\ell$}}}{M}{p} \MID \deref{M}{p} \MID \assign{L}{M}{p} \MID \ann{M}{A}{p}
  \end{array}
  \]}
  \caption{Syntax of \Surface (highlighted security labels \hl{$\ell$} default to \low if omitted)}
  \label{fig:surface-syntax}
\end{figure}

We present the syntax of the gradual language \Surface in
Figure~\ref{fig:surface-syntax}. The figure also includes the definitions for
security labels, blame labels, and types in \Surface.

For simplicity, we use the security lattice
$\langle \{\high, \low\} , \preccurlyeq, \curlyvee , \curlywedge \rangle$, where
$\high$ is for private data and $\low$ is for publicly disclosable data. Of
course, any lattice of security labels could be used in place of low and high.
The ordering is standard: $\low \preccurlyeq \high$ and $\high \npreccurlyeq
\low$. So information is allowed to flow from public sources to private sinks
but not the other way around. We refer to $\{\high,\low\}$ as \emph{specific
security labels}.

Types in \Surface have security labels associated with them, for example,
$\Bool_{\high}$ is the type for booleans with high security, $\Unit_{\low}$ is
the type for the unit value with low security, and $\Bool_{\unk}$ is the type of
a boolean whose security level is unknown at compile time. We refer to
$\{\high,\low,\unk\}$ as \emph{security labels}. A function type
$(\Fun{A}{\gc}{B})_g$ carries an additional security label \gc, which is the
type of the program counter (PC) to evaluate the body of the function.

Some terms in \Surface are annotated with an identifier called a blame label
(\bl{p}). When compiled to the intermediate representation, those terms generate
runtime checking (casts) that may fail. In case a check fails, it raises a cast
error, called \textit{blame}, that contains its blame label. In this way, the
programmer knows which cast is causing the problem and which part of the program
generates that cast.

The syntax of \Surface is similar to that of \GSLRef. \Surface supports
higher-order functions, mutable references, and explicit type annotations. The
main syntactic difference is that in \Surface, the security labels of literals
and newly created memory cells default to a specific label such as \low, while
in \GSLRef they default to a runtime unknown security level \unk. One thing to
note is that compared with literals, $\lambda$-abstractions in \Surface carry an
addition security label annotation $g$, which is the type of the PC label
expression used to evaluate the body of the $\lambda$. Same as the security
labels in type annotations, $g$ defaults to \unk if omitted by the programmer.

\subsection{Type System of \Surface}
\label{sec:surface-typing}

\begin{figure}[tbp]
\begin{align*}
\ell \sqcup \ell &= \ell & \fbox{$g \sqcup g$}\\
\unk \sqcup g &= g \\
g \sqcup \unk &= g \\[1ex]
\iota \sqcup \iota &= \iota & \fbox{$T \sqcup T$} \\
(\Refer{A}) \sqcup (\Refer{B}) &= \Refer{(A \sqcup B)} \\
(\Fun{A}{g_1}{B}) \sqcup (\Fun{C}{g_2}{D}) &= \Fun{(A \sqcup C)}{g_1 \sqcup g_2}{(B \sqcup D)} \\[1ex]
S_{g_1} \sqcup T_{g_2} &= (S \sqcup T)_{g_1 \sqcup g_2}  & \fbox{$A \sqcup A$}
\\[4ex]
%%%%%%
\ell_1 \lconsisjoin \ell_2 &= \ell_1 \curlyvee \ell_2 &\fbox{$g \lconsisjoin g$}\\
\text{-} \lconsisjoin \unk &= \unk \\
\unk \lconsisjoin \text{-} &= \unk \\[1ex]
\iota \consisjoin \iota &= \iota & \fbox{$T \consisjoin T$}\\
(\Refer{A}) \consisjoin (\Refer{B}) &= \Refer{(A \sqcup B)} \\
(\Fun{A}{g_1}{B}) \consisjoin (\Fun{C}{g_2}{D}) &= \Fun{(A \consismeet C)}{g_1 \lconsismeet g_2}{(B \consisjoin D)} \\[1ex]
S_{g_1} \consisjoin T_{g_2} &= (S \consisjoin T)_{g_1 \lconsisjoin g_2} & \fbox{$A \consisjoin A$}
\\[4ex]
%%%%%%
\ell_1 \lconsismeet \ell_2 &= \ell_1 \curlywedge \ell_2 & \fbox{$g \lconsismeet g$}\\
\text{-} \lconsismeet \unk &= \unk \\
\unk \lconsismeet \text{-} &= \unk \\[1ex]
\iota \consismeet \iota &= \iota & \fbox{$T \consismeet T$} \\
(\Refer{A}) \consismeet (\Refer{B}) &= \Refer{(A \sqcup B)} \\
(\Fun{A}{g_1}{B}) \consismeet (\Fun{C}{g_2}{D}) &= \Fun{(A \consisjoin C)}{g_1 \lconsisjoin g_2}{(B \consismeet D)} \\[1ex]
S_{g_1} \consismeet T_{g_2} &= (S \consismeet T)_{g_1 \lconsismeet g_2}  & \fbox{$A \consismeet A$}
\end{align*}
\\[1ex]
%%%%%%
\[
\mathit{stamp} \; (T_{g_1}) \; g_2 = T_{g_1 \lconsisjoin g_2}
\]
\caption{Auxiliary operators for security labels and types: join w.r.t precision (-$\sqcup$-),
consistent join (-$\lconsisjoin$- for labels and -$\consisjoin$- for types),
and consistent meet (-$\lconsismeet$- for labels and -$\consismeet$- for types).
Stamping for types}
\label{fig:grad-ops}
\end{figure}

Before we describe the type system for \Surface, we first define operators and
relations on security labels and types that are used by the typing rules.
Figure~\ref{fig:grad-ops} presents auxiliary operators on security labels and
types. These operators include join w.r.t precision, consistent join, consistent
meet, and the stamping operation on types. The operators are standard by following
those of \GSLRef and GLIO. Join w.r.t precision returns the least upper bound of
the precision of two labels or two types, for example
\[
(\Fun{\Bool_{\low}}{\unk}{\Bool_{\high}})_{\unk} \sqcup
(\Fun{\Bool_{\low}}{\low}{\Bool_{\high}})_{\unk} =
(\Fun{\Bool_{\low}}{\low}{\Bool_{\high}})_{\unk}
\]
Consistent join of security labels resorts to security lattice join if both
labels are statically known; otherwise the operator returns \unk if at least one
label is \unk. Consistent join of types is recursive on the structure of the
types, with the PC labels and the domain types in function types being
contravariant and the referenced types being invariant. The consistent meet
operators of security labels and types are analogous to consistent join. The
stamping operator is a shorthand that computes the consistent join of the
top-level label of the type with another label, while keeping the rest of the
type unchanged.

\begin{figure}[tbp]
\raggedright
  \fbox{$\Gamma ; g \vdash M : A$}
  \begin{gather*}
  \small
    {\vdash}\mathit{var}~
    \inference{\Gamma \ni x : A}
              {\Gamma; g \vdash x : A}
    \quad
    {\vdash}\mathit{const}~
    \inference{k : \iota}
              {\Gamma; g \vdash \const{k}{\ell} : \iota_\ell}
    \\[1ex]
    {\vdash}\mathit{lam}~
    \inference{(\Gamma , x{:}A); g_2 \vdash N : B}
              {\Gamma; g_1 \vdash \lam{g_2}{x}{A}{N}{\ell} : (\Fun{A}{g_2}{B})_\ell}
    \\[1ex]
    {\vdash}\mathit{app}~
    \inference{\Gamma; g \vdash L : (\Fun{A}{g_2}{B})_{g_1} &
               \Gamma; g \vdash M : A' \\
               A' \lesssim A & g \precsim g_2 & g_1 \precsim g_2}
              {\Gamma; g \vdash \app{L}{M}{p} : \textit{stamp}\;B\;g_1}
    \\[1ex]
    {\vdash}\mathit{let}~
    \inference{\Gamma; g \vdash M : A \\
               (\Gamma , x{:}A) ; g \vdash N : B}
              {\Gamma; g \vdash \letexp{x}{M}{N} : B}
    \\[1ex]
    {\vdash}\mathit{if}~
    \inference{\Gamma; g_2 \vdash L : \Bool_{g_1} \\
               \Gamma; g_2 \lconsisjoin g_1 \vdash M : A &
               \Gamma; g_2 \lconsisjoin g_1 \vdash N : B \\
               A \consisjoin B = C}
              {\Gamma; g_2 \vdash \ifexp{L}{M}{N}{p} : \textit{stamp}\;C\;g_1}
    \\[1ex]
    {\vdash}\mathit{ref}~
    \inference{\Gamma; g_2 \vdash M : T_{g_1} \\
               T_{g_1} \lesssim T_\ell & \highlightblue{g_2 \precsim \ell}}
              {\Gamma; g_2 \vdash \refexp{\ell}{M}{p} : (\Refer{T_\ell})_{\low}}
    \quad
    {\vdash}\mathit{deref}~
    \inference{\Gamma; g_2 \vdash M : (\Refer{A})_{g_1}}
              {\Gamma; g_2 \vdash \deref{M}{p} : \textit{stamp}\;A\;g_1}
    \\[1ex]
    {\vdash}\mathit{assign}~
    \inference{\Gamma; g_2 \vdash L : (\Refer{T_{\hat{g}}})_{g_1} &
               \Gamma; g_2 \vdash M : A \\
               A \lesssim T_{\hat{g}} & \highlightblue{g_2 \precsim \hat{g}} & \highlightblue{g_1 \precsim \hat{g}}}
              {\Gamma; g_2 \vdash \assign{L}{M}{p} : \Unit_{\low}}
    \quad
    {\vdash}\mathit{ann}~
    \inference{\Gamma; g \vdash M : A' \\ A' \lesssim A}
              {\Gamma; g \vdash \ann{M}{A}{p} : A}
  \end{gather*}
  \caption{Typing rules of the surface language \Surface. Side conditions about the heap policy
  are \highlightblue{\text{highlighted}}}
  \label{fig:surface-typing-full}
\end{figure}

\subsection{Semantics of \Surface}
\label{sec:surface-semantics}

%% foreshadow the semantics by defining the eval function

\section{\Surface in Action}
\label{sec:examples}

I first show that gradual IFC embeds static IFC, by reviewing type-based static
IFC using fully-annotated \Surface programs. I then show that \Surface enables a
gradual transition into dynamic IFC, when type annotations become less precise.
I review the counterexamples of \textcite{Toro:2018aa} and demonstrate that
unlike \GSLRef, the NSU checking in \Surface based on security coercions
satisfies the gradual guarantee. Finally, I show that \Surface supports
type-based reasoning through free theorems, because \Surface is vigilant and
performs type-guided classification just like \GSLRef.

\subsection{The Gradual Transition Between Static and Dynamic IFC in \Surface}
\label{sec:example1}

For simplicity, we use the security lattice $\langle \{\high, \low\}
, \preccurlyeq, \curlyvee , \curlywedge \rangle$, where $\high$ is for
private data and $\low$ is for publicly disclosable data. The ordering
is standard: $\low \preccurlyeq \high$ and
$\high \npreccurlyeq \low$. So information is allowed to flow from
public sources to private sinks but not the other way around.
We refer to $\{\high,\low\}$ as \emph{specific security labels}.

\subsection{Implicit Flow, NSU Checks, Unknown Security, and the Gradual Guarantee}
\label{sec:example2}

%% TODO define the precision relations here

\subsection{Type-Based Reasoning in \Surface}
\label{sec:example3}

\section{The Static and Dynamic Extremes of \Surface}
\label{sec:embedding}
