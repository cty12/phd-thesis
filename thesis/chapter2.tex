\chapter{Gradual Information-Flow Control (IFC) in \Surface}
\label{ch:examples}

In this chapter, I first define the gradual IFC surface language \Surface, by
presenting its syntax, type system, and semantics in
Section~\ref{sec:surface-def}. After that, I put \Surface into action in
Section~\ref{sec:examples}. I present example programs to demonstrate how
\Surface enables a gradual and smooth transition between static and dynamic IFC,
while supporting type-based reasoning and satisfying the gradual guarantee at
the same time. Finally, in Section~\ref{sec:embedding}, I conclude the chapter
by discussing the static and the dynamic extremes of \Surface. \Surface enables
a continuum of IFC enforcement between the static and dynamic extremes that it
embeds.

\section{The Gradual IFC Language \Surface}
\label{sec:surface-def}

This section is organized as follows. I first present the syntax of \Surface in
Section~\ref{sec:surface-syntax}. I then present the type system for \Surface in
Section~\ref{sec:surface-typing}. Finally, I discuss the semantics of \Surface
by defining the \texttt{eval} function in Section~\ref{sec:surface-semantics}.

\subsection{The Syntax of \Surface}
\label{sec:surface-syntax}

\begin{figure}[tbp]
\raggedright
  {\small
  \[
  \begin{array}{rcll}
    \text{specific security labels} & \ell & \in & \{ \low , \high \} \\
    \text{security labels}  & g    & ::= & \unk \MID \ell \\
    \text{base types}               & \iota     & ::= & \Unit \MID \Bool \\
    \text{raw types}                & T, S      & ::= & \iota \MID \Fun{A}{\gc}{B} \mid \Refer{(T_g)} \\
    \text{blame labels}         & \bl{p}, \bl{q}     &      & \\
    \text{types}                    & A, B      & ::= & T_g \\
    \text{terms}                & L , M , N & ::=  & x \MID \const{k}{\text{\hl{$\ell$}}} \MID \lam{g}{x}{A}{N}{\text{\hl{$\ell$}}} \MID \app{L}{M}{p} \\
    &                                       & \MID & \ifexp{L}{M}{N}{p} \MID \letexp{x}{M}{N} \\
    &                                       & \MID & \refexp{\text{\hl{$\ell$}}}{M}{p} \MID \deref{M}{p} \MID \assign{L}{M}{p} \MID \ann{M}{A}{p}
  \end{array}
  \]}
  \caption{Syntax of \Surface (highlighted security labels \hl{$\ell$} default to \low if omitted)}
  \label{fig:surface-syntax}
\end{figure}

The syntax of the gradual language \Surface is shown in
Figure~\ref{fig:surface-syntax}. The figure also includes the definitions for
security labels, security types, and blame labels.

For simplicity, I will use a two-point security lattice $\langle \{\high, \low\}
, \preccurlyeq, \curlyvee , \curlywedge \rangle$, where $\high$ is for private,
sensitive data and $\low$ is for public, disclosable data. Of course, any
lattice of security labels could be used in place of low and high. The ordering
is standard: $\low \preccurlyeq \high$ and $\high \npreccurlyeq \low$. So
information is allowed to flow from public sources to private sinks but not the
other way around. I refer to $\{\high,\low\}$ as \emph{specific security
labels}.

Types in \Surface have security labels associated with them, for example,
$\Bool_{\high}$ is the type for booleans with high security, $\Unit_{\low}$ is
the type for the unit value with low security, and $\Bool_{\unk}$ is the type of
a boolean whose security level is unknown at compile time. I refer to
$\{\high,\low,\unk\}$ as \emph{security labels}. A function type
$(\Fun{A}{\gc}{B})_g$ carries an additional security label \gc, which is the
type of the program counter (PC) to evaluate the body of the function.

Some terms in \Surface are annotated with an identifier called a blame label
(\bl{p}). When compiled to the intermediate representation, those terms generate
runtime checking (casts) that may fail. In case a check fails, it raises a cast
error, called \textit{blame}, that contains its blame label. In this way, the
programmer knows which cast is causing the problem and which part of the program
generates that cast.

To enable information-flow control, \Surface allows the programmer to annotate
constants, mutable references, and $\lambda$-abstractions with a specific
security label. \Surface ensures that if a value is annotated with $\high$, it
will not flow into a sink that is $\low$ security. If the programmer does not
annotate a value with a label, \Surface defaults the value's label to \low. So
\texttt{true} is shorthand for $\mathtt{true}_{\low}$. \Surface supports
higher-order functions, mutable references, and explicit type annotations. One
thing to note is that compared with literals, $\lambda$-abstractions in \Surface
carry an addition security label annotation $g$, which is the type of the PC
label expression used to evaluate the body of the $\lambda$. Same as the
security labels in type annotations, $g$ defaults to \unk if omitted. For
readers familiar with \GSLRef, the syntax of \Surface is similar to that of
\GSLRef. The main syntactic difference is that in \Surface, the security labels
of literals and newly created memory cells default to a specific label such as
\low, while in \GSLRef they default to a runtime unknown security level \unk. I
am going to show in Section~\ref{sec:example2} that defaulting to a specific
security label helps us resolve the tension between noninterference and the
gradual guarantee.

\subsection{The Type System of \Surface}
\label{sec:surface-typing}

I first define operators and relations on security labels and types that are
used by the typing rules in Section~\ref{sec:ops-and-rels}. I then introduce
the typing rules of \Surface in Section~\ref{sec:surface-typing-rules}.

\subsubsection{Operators and Relations on Security Labels and Types}
\label{sec:ops-and-rels}

\begin{figure}[tbp]
\begin{align*}
\ell \sqcup \ell &= \ell & \fbox{$g \sqcup g$}\\
\unk \sqcup g &= g \\
g \sqcup \unk &= g \\[1ex]
\iota \sqcup \iota &= \iota & \fbox{$T \sqcup T$} \\
(\Refer{A}) \sqcup (\Refer{B}) &= \Refer{(A \sqcup B)} \\
(\Fun{A}{g_1}{B}) \sqcup (\Fun{C}{g_2}{D}) &= \Fun{(A \sqcup C)}{g_1 \sqcup g_2}{(B \sqcup D)} \\[1ex]
S_{g_1} \sqcup T_{g_2} &= (S \sqcup T)_{g_1 \sqcup g_2}  & \fbox{$A \sqcup A$}
\\[4ex]
%%%%%%
\ell_1 \lconsisjoin \ell_2 &= \ell_1 \curlyvee \ell_2 &\fbox{$g \lconsisjoin g$}\\
\text{-} \lconsisjoin \unk &= \unk \\
\unk \lconsisjoin \text{-} &= \unk \\[1ex]
\iota \consisjoin \iota &= \iota & \fbox{$T \consisjoin T$}\\
(\Refer{A}) \consisjoin (\Refer{B}) &= \Refer{(A \sqcup B)} \\
(\Fun{A}{g_1}{B}) \consisjoin (\Fun{C}{g_2}{D}) &= \Fun{(A \consismeet C)}{g_1 \lconsismeet g_2}{(B \consisjoin D)} \\[1ex]
S_{g_1} \consisjoin T_{g_2} &= (S \consisjoin T)_{g_1 \lconsisjoin g_2} & \fbox{$A \consisjoin A$}
\\[4ex]
%%%%%%
\ell_1 \lconsismeet \ell_2 &= \ell_1 \curlywedge \ell_2 & \fbox{$g \lconsismeet g$}\\
\text{-} \lconsismeet \unk &= \unk \\
\unk \lconsismeet \text{-} &= \unk \\[1ex]
\iota \consismeet \iota &= \iota & \fbox{$T \consismeet T$} \\
(\Refer{A}) \consismeet (\Refer{B}) &= \Refer{(A \sqcup B)} \\
(\Fun{A}{g_1}{B}) \consismeet (\Fun{C}{g_2}{D}) &= \Fun{(A \consisjoin C)}{g_1 \lconsisjoin g_2}{(B \consismeet D)} \\[1ex]
S_{g_1} \consismeet T_{g_2} &= (S \consismeet T)_{g_1 \lconsismeet g_2}  & \fbox{$A \consismeet A$}
\end{align*}
\\[1ex]
%%%%%%
\[
\mathit{stamp} \; (T_{g_1}) \; g_2 = T_{g_1 \lconsisjoin g_2}
\]
\caption{Auxiliary operators for security labels and types: join w.r.t precision (-$\sqcup$-),
consistent join (-$\lconsisjoin$- for labels and -$\consisjoin$- for types),
and consistent meet (-$\lconsismeet$- for labels and -$\consismeet$- for types).
Stamping for types}
\label{fig:grad-ops}
\end{figure}

Figure~\ref{fig:grad-ops} presents auxiliary operators on security labels and
types. These operators include join w.r.t precision, consistent join, consistent
meet, and the stamping operation on types. The operators are standard by following
those of \GSLRef and GLIO. Join w.r.t precision returns the least upper bound of
the precision of two labels or two types, for example
\[
(\Fun{\Bool_{\low}}{\unk}{\Bool_{\high}})_{\unk} \sqcup
(\Fun{\Bool_{\low}}{\low}{\Bool_{\high}})_{\unk} =
(\Fun{\Bool_{\low}}{\low}{\Bool_{\high}})_{\unk}
\]
Consistent join of security labels resorts to security lattice join if both
labels are statically known; otherwise the operator returns \unk if at least one
label is \unk. Consistent join of types is recursive on the structure of the
types, with the PC labels and the domain types in function types being
contravariant and the referenced types being invariant. The consistent meet
operators of security labels and types are analogous to consistent join. The
stamping operator is a shorthand that computes the consistent join of the
top-level label of the type with another label, while keeping the rest of the
type unchanged.

\begin{figure}[ht]
  \raggedright
  \fbox{$g_1 \precsim g_2$}
  \begin{gather*}
    {\precsim}\unk~
    \inference{}{g \precsim \unk}
    \qquad
    \unk{\precsim}~
    \inference{}{\unk \precsim g}
    \qquad
        {\precsim}\textit{-}\ell~
        \inference{\ell_1 \preccurlyeq \ell_2}{\ell_1 \precsim \ell_2}
  \end{gather*}
  \raggedright
  \fbox{$S \lesssim T$}
  \begin{gather*}
          {\lesssim}\textit{-}\iota~
          \inference{}{\iota \lesssim \iota}
          \quad
              {\lesssim}\textit{-ref}~
              \inference{A \lesssim B & B \lesssim A}{\Refer{A} \lesssim \Refer{B}} \quad
                        {\lesssim}\textit{-fun}~
                        \inference{g_2 \precsim g_1 & C \lesssim A & B \lesssim D}
                                  {\Fun{A}{g_1}{B} \lesssim \Fun{C}{g_2}{D}}
  \end{gather*}
  \raggedright
  \fbox{$A \lesssim B$}
  \begin{gather*}
    {\lesssim}\textit{-}\tau~
    \inference{g_1 \precsim g_2 & S \lesssim T}{S_{g_1} \lesssim T_{g_2}}
  \end{gather*}
  \caption{Consistent subtyping for labels and types}
  \label{fig:consis-sub}
\end{figure}

Figure~\ref{fig:consis-sub} presents the definitions of consistent subtyping for
security labels and types, which will be used in the type system of \Surface.
Consistent subtyping is the composition of consistency and subtyping. The
following are equivalent: (1) $A \lesssim B$, (2) $A \sim C <: B$ for some $C$,
and (3) $A <: D \sim B$ for some $D$. The consistent subtyping relations in
\Surface are standard, similar to those in \GSLRef and GLIO, with the PC and
domain type in a function type being contravariant (rule
${\lesssim}\textit{-fun}$) and the referenced type being invariant
(rule ${\lesssim}\textit{-ref}$).

\begin{figure}[tbp]
  \raggedright
  \fbox{$g_1 \sqsubseteq g_2$}
  \begin{gather*}
    \unk{\sqsubseteq}~
    \inference{}{\unk \sqsubseteq g}
    \qquad\quad
    \ell{\sqsubseteq}\ell~
    \inference{}{\ell \sqsubseteq \ell}
  \end{gather*}
  \fbox{$S \sqsubseteq T$}
  \begin{gather*}
    {\sqsubseteq}\textit{-}\iota~
    \inference{}{\iota \sqsubseteq \iota}
    \quad
        {\sqsubseteq}\textit{-ref}~
        \inference{A \sqsubseteq B}{\Refer{A} \sqsubseteq \Refer{B}}
        \quad
            {\sqsubseteq}\textit{-fun}~
            \inference{g_1 \sqsubseteq g_2 &
              A \sqsubseteq C &
              B \sqsubseteq D}
                      {\Fun{A}{g_1}{B} \sqsubseteq \Fun{C}{g_2}{D}}
  \end{gather*}
  \fbox{$A \sqsubseteq B$}
  \begin{gather*}
    {\sqsubseteq}\textit{-}\tau~
    \inference{g_1 \sqsubseteq g_2 & S \sqsubseteq T}{S_{g_1} \sqsubseteq T_{g_2}}
  \end{gather*}
  \caption{Precision of security labels and types}
  \label{fig:type-prec}
\end{figure}

I define a precision ordering $\sqsubseteq$ on security labels and security
types. For security labels, the statically unknown label \unk is the most
imprecise, so $\unk \sqsubseteq g$ for any label $g$ and $\ell \sqsubseteq \ell$
for any specific security label $\ell$. The precision ordering extends to types
in a natural way, so for example, $\Bool_{\unk} \sqsubseteq \Bool_{\low}$ and
$(\Fun{\Bool_{\low}}{\unk}{\Bool_{\high}})_{\unk} \sqsubseteq $.
Figure~\ref{fig:type-prec} of the Appendix gives the definition of precision on
types.

\subsubsection{Typing Rules for \Surface}
\label{sec:surface-typing-rules}

\begin{figure}[tbp]
\raggedright
  \fbox{$\Gamma ; g \vdash M : A$}
  \begin{gather*}
  \small
    {\vdash}\mathit{var}~
    \inference{\Gamma \ni x : A}
              {\Gamma; g \vdash x : A}
    \quad
    {\vdash}\mathit{const}~
    \inference{k : \iota}
              {\Gamma; g \vdash \const{k}{\ell} : \iota_\ell}
    \\[1ex]
    {\vdash}\mathit{lam}~
    \inference{(\Gamma , x{:}A); g_2 \vdash N : B}
              {\Gamma; g_1 \vdash \lam{g_2}{x}{A}{N}{\ell} : (\Fun{A}{g_2}{B})_\ell}
    \\[1ex]
    {\vdash}\mathit{app}~
    \inference{\Gamma; g \vdash L : (\Fun{A}{g_2}{B})_{g_1} &
               \Gamma; g \vdash M : A' \\
               A' \lesssim A & g \precsim g_2 & g_1 \precsim g_2}
              {\Gamma; g \vdash \app{L}{M}{p} : \textit{stamp}\;B\;g_1}
    \\[1ex]
    {\vdash}\mathit{let}~
    \inference{\Gamma; g \vdash M : A \\
               (\Gamma , x{:}A) ; g \vdash N : B}
              {\Gamma; g \vdash \letexp{x}{M}{N} : B}
    \\[1ex]
    {\vdash}\mathit{if}~
    \inference{\Gamma; g_2 \vdash L : \Bool_{g_1} \\
               \Gamma; g_2 \lconsisjoin g_1 \vdash M : A &
               \Gamma; g_2 \lconsisjoin g_1 \vdash N : B \\
               A \consisjoin B = C}
              {\Gamma; g_2 \vdash \ifexp{L}{M}{N}{p} : \textit{stamp}\;C\;g_1}
    \\[1ex]
    {\vdash}\mathit{ref}~
    \inference{\Gamma; g_2 \vdash M : T_{g_1} \\
               T_{g_1} \lesssim T_\ell & \highlightblue{g_2 \precsim \ell}}
              {\Gamma; g_2 \vdash \refexp{\ell}{M}{p} : (\Refer{T_\ell})_{\low}}
    \quad
    {\vdash}\mathit{deref}~
    \inference{\Gamma; g_2 \vdash M : (\Refer{A})_{g_1}}
              {\Gamma; g_2 \vdash \deref{M}{p} : \textit{stamp}\;A\;g_1}
    \\[1ex]
    {\vdash}\mathit{assign}~
    \inference{\Gamma; g_2 \vdash L : (\Refer{T_{\hat{g}}})_{g_1} &
               \Gamma; g_2 \vdash M : A \\
               A \lesssim T_{\hat{g}} & \highlightblue{g_2 \precsim \hat{g}} & \highlightblue{g_1 \precsim \hat{g}}}
              {\Gamma; g_2 \vdash \assign{L}{M}{p} : \Unit_{\low}}
    \quad
    {\vdash}\mathit{ann}~
    \inference{\Gamma; g \vdash M : A' \\ A' \lesssim A}
              {\Gamma; g \vdash \ann{M}{A}{p} : A}
  \end{gather*}
  \caption{Typing rules of \Surface. Side conditions about the heap policy are
    \highlightblue{\text{highlighted}}}
  \label{fig:surface-typing-full}
\end{figure}

The typing rules for \Surface are shown in Figure~\ref{fig:surface-typing-full}.
They are directly adapted from those of \GSLRef, by changing the security labels
on values to disallow the \unk label. The type system of \GSLRef is derived from
its static counterpart \SSLRef by replacing labels and types as well as their
operators and predicates with the gradual variants, while \SSLRef is in turn an
adaptation of prior security-typed languages such as \textcite{Fennell:2013ab,
  heintze1998slam, zdancewic2002programming}.

For example, in \SSLRef the typing rule of application looks like:
\begin{equation*}
{\vdash}\textit{app-SSLRef}~
\inference{\Gamma; \pc \vdash L : (\Fun{A}{\pc'}{B})_\ell & \Gamma; \pc \vdash M : A' \\
  A' <: A & \pc \preccurlyeq \pc' & \ell \preccurlyeq \pc'}
{\Gamma; \pc \vdash \app{L}{M}{} : \mathit{stamp}\;B\;\ell}
\end{equation*}
where $A' <: A$ is the usual type subsumption of function argument. The side
conditions $\ell \preccurlyeq \pc'$ and $\pc \preccurlyeq \pc'$ restricts the PC
label on the function type so that no information is leaked through side
effects. The type of the application has label that is the join of the label on
$B$ and $\ell$ ($\mathit{stamp}\;B\;\ell$). In \Surface, the typing judgment
takes the form $\Gamma ; g \vdash M : A$, where the static PC label $g$ and the
type $A$ become gradual (may be or contain \unk). Like \GSLRef, I replace label
partial order with label consistent subtyping, type subtyping with type
consistent subtyping, and label join with label consistent join and get rule
${\vdash}\mathit{app}$.

The only major difference from the type system of \GSLRef is that because of the
concrete label restriction on the syntax of constants and
$\lambda$-abstractions, these terms must have concrete labels at the top level
of their respective types (rule ${\vdash}\mathit{const}$ and
${\vdash}\mathit{lam}$). Similarly, the type of the value in a newly allocated
cell (rule ${\vdash}\mathit{ref}$) has a concrete top-level label:
$(\Refer{T_{\text{\hl{$\ell$}}}})_{\low}$. The reference itself has a \low label
because it is newly created and cannot leak information.

\subsection{The Semantics of \Surface}
\label{sec:surface-semantics}

%% foreshadow the semantics by defining the eval function

I define the semantics of \Surface through a compile function that takes a
well-typed \Surface program and returns a cast-calculus (\CC) term. The compile
function takes the form $\compile{M} = M'$, where $M$ is a \Surface program and
$M'$ is a \CC term.

I define the evaluation function for \Surface by (1) compiling from \Surface to
\CC and (2) running the compiled \CC term using its operational semantics.
\begin{align*}
  \mathit{eval}(M) =&\,V\;\text{if}\;\reducemult{(\compile{M})}{\emptyset}{\low}{V}{\mu} \\
  \mathit{eval}(M) =&\,\blame{\bl{p}}\;\text{if}\;\reducemult{(\compile{M})}{\emptyset}{\low}{\blame{\bl{p}}}{\mu}
\end{align*}

I will define the compile function and the operational semantics for \CC in
Chapter~\ref{ch:sem}.

\section{\Surface in Action}
\label{sec:examples}

This section is organized as follows. In Section~\ref{sec:example1}, I review
the basics of gradual IFC using \Surface programs. I show that \Surface enables
a gradual transition between static and dynamic IFC. In
Section~\ref{sec:example2}, I review the counterexamples of
\textcite{Toro:2018aa} and demonstrate that the tension between security and the
gradual guarantee can be solved by removing \unk from the runtime security
labels. Finally, I show that \Surface enables the same type-based reasoning
capabilities through free theorems as \GSLRef, because \Surface is vigilant and
performs type-guided classification.

\subsection{The Gradual Transition Between Static and Dynamic IFC in \Surface}
\label{sec:example1}

In this section I review the basic concepts of gradual information flow control
using \Surface, establishing the intuition that \Surface enables a smooth,
gradual transition between static and dynamic IFC. I start with fully static
\Surface programs and show that \Surface can behave like a static security-typed
language, guarding against both illegal explicit and implicit flows at compile
time. I then replace some security label annotations in types with \unk, so that
the programs become partially typed and the typing information alone is
insufficient to enforce IFC. I show that security coercions, serving as the
runtime security monitor of \Surface, are able to capture both explicit flow and
implicit flow violations at runtime, thereby preventing information leakage and
enforcing security.

I model I/O with two functions, \texttt{user-input} and \texttt{publish}: the
former returns a high-security boolean that represents sensitive input
information; the latter takes a low-security boolean and publishes it into a
publicly visible channel.

\subsubsection{Gradual IFC includes static IFC}

For statically typed programs, \Surface behaves just like a statically
typed IFC language. Consider the following well-behaved \Surface
program that takes in a high-security user input, passes it to the
function \texttt{fconst} that ignores the input and
returns \texttt{false}, which is then published.

\begin{lstlisting}[style=tt]
  let fconst = |$\lambda$| b : |$\Bool_{\high}$|. false in
  let input  = user-input () in
  let result = fconst input in
    publish result
\end{lstlisting}

The program type-checks and runs without error, with no need for
runtime checks to enforce security. Indeed, a malicious party cannot
infer anything about the high-security input because (1) the return
value of \texttt{fconst} is always the same value \false~ (2)
the value \false~is of low security, so the explicit flow
into \texttt{publish} is allowed.

If we replace \texttt{fconst} with the identity function \texttt{fid} with
parameter type $\Bool_{\low}$, the program becomes ill-typed as is usual for a
statically typed IFC language: the type system disallows the explicit flow from
the high-security input to \texttt{fid}, which expects a low-security boolean
value.

\begin{lstlisting}[style=tt]
  let fid    = |$\lambda$| b : |\colorbox{highlight}{$\Bool_{\low}$}|. b in
  let input  = user-input () in
  let result = fid input in      |\graytext{// static error}|
    publish result
\end{lstlisting}

Sometimes the observable behaviors of a program can depend on its branching
structure. If some of the branch conditions have a data dependency on
high-security input, a malicious party might be able to infer it from the
observable behaviors, giving rise to illegal \textit{implicit flows}
~\parencite{denning1976lattice}, which must be ruled out to guarantee security.

Consider the following program in which the function \texttt{flip} contains a
conditional expression, whose condition is dependent on a high-security user
input. Its two branches return different low-security booleans, creating a
potential implicit flow from high to low.

\begin{lstlisting}[style=tt]
  let flip : |$\Bool_{\high}$| -> |$\Bool_{\low}$| =
       |$\lambda$| b : |$\Bool_{\high}$|. |\colorbox{highlight}{\texttt{if b then false else true}}| in
  let input  = user-input () in
  let result = flip input in
    publish result
\end{lstlisting}

\noindent Perhaps the programmer mistakenly annotated the return type of
\texttt{flip} thinking that it must return $\Bool_{\low}$, because both branches
contain low-security values. As is typical of statically typed IFC languages,
the type system of \Surface rejects this program, thereby preventing an
information leak through an implicit flow. To see why, note that the branch
condition is of high security, so the type of the \texttt{if} expression as a
whole is $\Bool_{\high}$. In particular, the type checker computes the security
level of an \texttt{if} to be the join of its branches (both \low) and the
condition (\high), yielding $\low \curlyvee \high = \high$. The \texttt{flip}
function is expected to return $\Bool_{\low}$ according to its type annotation,
but returns $\Bool_{\high}$ because of the conditional, $\high \npreccurlyeq
\low$, so the program is ill-typed.

To summarize, \Surface behaves just like a static security-typed language in the
above examples. When everything is statically typed, the type system of \Surface
guards against illegal information flows, whether explicit or implicit.

\subsubsection{Gradual IFC enables a mixture of static and dynamic IFC}

I have shown that security labels (\low and \high) can appear in type
annotations in a program, such as $\Bool_{\low}$ and $\Bool_{\high}$. \Surface
also provides the \textit{unknown security label}, written \unk, for use in type
annotations. I will explain how the unknown security label works in the
following discussion.

Let us return to the \texttt{fconst} example, except this time the type of
parameter \texttt{b} is $\Bool_{\unk}$.

\begin{lstlisting}[style=tt]
  let fconst = |$\lambda$| b : |\colorbox{highlight}{$\Bool_{\unk}$}|. false in
  let input  = user-input () in
  let result = fconst input in
    publish result
\end{lstlisting}

\noindent The type system of \Surface accepts this program because, in
the function call \texttt{fconst input}, it allows an implicit conversion from
the type of \texttt{input}, which is $\Bool_{\high}$, to the parameter
type $\Bool_{\unk}$. This program runs to completion and publishes
\texttt{false}.

Now suppose I again replace \texttt{fconst} with \texttt{fid}, but keep the
parameter type of $\Bool_{\unk}$.

\begin{lstlisting}[style=tt]
  let fid    = |$\lambda$| b : |\colorbox{highlight}{$\Bool_{\unk}$}|. b in
  let input  = user-input () in
  let result = fid input in
    publish result
\end{lstlisting}

\noindent The type system of \Surface still accepts this program. The type of
\texttt{result} changes to $\Bool_{\unk}$ but in the call \texttt{publish
  result}, the type system allows an implicit conversion from $\Bool_{\unk}$ to
$\Bool_{\low}$. The security leak in this program is not caught statically;
instead it is caught dynamically.

The dynamic semantics of \Surface is defined by compilation into the \CC
calculus by inserting casts. In \CC, explicit casts are represented as
\textit{security coercions} that monitor the flow of information. I use the
standard syntax for coercions~\parencite{Henglein:1994nz} but with adaptations
to handle IFC. A coercion whose target is \unk (and source is not \unk) is an
\emph{injection}, and is indicated by an exclamation mark. A coercion whose
source is \unk (and target is not \unk) is a \emph{projection}, and is indicated
by a question mark. The projections perform runtime checks that may fail.

The translation from \Surface to \CC inserts a security coercion wherever an
implicit cast occurred in the type checking of the \Surface term. Here is the
result of cast insertion on the above program:

\begin{lstlisting}[style=tt]
  let fid    = |$\lambda$| b. b in
  let input  = user-input () in
  let result = fid (input |\colorbox{highlight}{\textlangle\,\inj{\high}\,\textrangle}|) in
    publish (result |\colorbox{highlight}{\textlangle\,\proj{\low}{p}\,\textrangle}|)
\end{lstlisting}

The coercion on Line 3 (\inj{\high}) is an injection, casting from \high to
\unk.
%
The coercion on line 4 (\proj{\low}{p}) is a projection, casting from \unk to
\low.
%
At runtime, a projection checks whether the incoming value has a security level
that is less than or equal to the target security level.
%
Now suppose we run the above example with input \texttt{true}. The injection on
line 3 will create an injected value $\cccast{\true_{\high}}{\inj{\high}}$. This
value is passed to and returned from \texttt{fid}, and then projected to $\low$.
Because $\high$ is greater than $\low$, the projection fails.

Each projection is annotated with an identifier called a blame label
(\bl{p}).  In case a projection fails, it raises a cast error,
called \textit{blame}, that contains its blame label. In this way, the
programmer knows which cast is causing the problem.  This feature is
often referred to as
\textit{blame tracking}~\parencite{Findler:2002eu,Wadler:2009qv}.
Blame tracking is especially useful during the software development
process, but in the context of IFC, one may not want blame to be
observable in a production system as it could reveal information.
This can be handled by causing the program to diverge whenever blame
is detected, possibly sending a private error message to the software
developer.

Next let us return to the \texttt{flip} example to see how gradual IFC prevents
illegal implicit flows. Suppose that I change the parameter type of the
$\lambda$ from $\Bool_{\high}$ to $\Bool_{\unk}$. The return type remains
$\Bool_{\low}$, to conform with the signature of \texttt{publish}. The
definition of \texttt{flip} (line 1 and line 2) thus becomes:

\begin{lstlisting}[style=tt]
  let flip : |\colorbox{highlight}{$\Bool_{\unk}$}| -> |$\Bool_{\low}$| =
       |$\lambda$| b : |\colorbox{highlight}{$\Bool_{\unk}$}|. if b then false else true in
\end{lstlisting}

\noindent This change makes the program well-typed in \Surface. The IFC
enforcement of the implicit flow is deferred until runtime because the branch
condition now has type $\Bool_{\unk}$, with an unknown security level.

Next, let us consider the runtime behavior of this program. The result of cast
insertion on the \Surface program is the following \CC term:

\begin{lstlisting}[style=tt]
  let flip   = |$\lambda$| b. ((if|${\star}$| b then (false |\colorbox{highlight}{\texttt{⟨\,\inj{\low}\,⟩}}|)
                            else (true |\colorbox{highlight}{\texttt{⟨\,\inj{\low}\,⟩}}|)) |\colorbox{highlight}{\texttt{⟨\,\proj{\low}{p}\,⟩}}|) in
  let input  = user-input () in
  let result = flip (input |\colorbox{highlight}{\texttt{⟨\,\inj{\high}\,⟩}}|) in
    publish result
\end{lstlisting}

\noindent where the \texttt{if} is changed
to $\mathtt{if}\star$ because the condition expression has static
security level \unk{}.  The type checking rule for $\mathtt{if}\star$
requires the two branches to have security level \unk{} and the
security level of the $\mathtt{if}\star$ is a whole is also \unk{}.
%
If we run the program with \texttt{true} or \texttt{false} as input, the \CC
term reduces to \texttt{blame} \bl{p} with either input, thus capturing the
illegal implicit flow and preventing the leakage of the private user input. The
following reduction shows the highlights of running this program with input
\texttt{true} (\texttt{false} is analogous):

{\small
  \begin{align*}
    \longrightarrow^{*}
    \begin{split}
      &\quad \texttt{let result = ($\lambda$ b. ((if${\star}$ b then (false ⟨\,\inj{\low}\,⟩)} \\[-3pt]
      &\quad\quad\qquad\texttt{else (true ⟨\,\inj{\low}\,⟩)) ⟨\,\proj{\low}{p}\,⟩)) (true ⟨\,\inj{\high}\,⟩) in ...}
    \end{split} \\[1ex]
    \longrightarrow^{*}
    \begin{split}
      &\quad \texttt{let result = prot \low ((if${\star}$ (true ⟨\,\inj{\high}\,⟩) then (false ⟨\,\inj{\low}\,⟩)} \\[-3pt]
      &\quad\quad\qquad\texttt{else (true ⟨\,\inj{\low}\,⟩)) ⟨\,\proj{\low}{p}\,⟩) in ...}
    \end{split}\\[1ex]
    \longrightarrow^{*} &
    \quad \texttt{let result = prot \low ((prot \high (false ⟨\,\inj{\low}\,⟩)) ⟨\,\proj{\low}{p}\,⟩) in ...} \\[1ex]
    \longrightarrow^{*} &
    \quad\texttt{let result = prot \low (false ⟨\,\up\seq\inj{\high}\,⟩ ⟨\,\proj{\low}{p}\,⟩) in ...} \\
    \longrightarrow^{*} &
    \quad\texttt{blame \bl{p}}
\end{align*}}

First, the $\lambda$ is bound to \texttt{flip} and the input \texttt{true} is
bound to the \texttt{input} variable. We then inject the input, producing the
value $(\cccast{\true_{\high}}{\inj{\high}})$. We call \texttt{flip} and the
$\mathtt{if}\star$ branches on this injected boolean, evaluating the ``then''
branch to the result $(\cccast{\false_{\low}}{\inj{\low}})$ and then, to protect
against implicit flows, the $\mathtt{if}\star$ upgrades the result to $\high$ to
match the runtime security level of the condition
$(\cccast{\true_{\high}}{\inj{\high}})$, producing
$(\cccast{\false_{\low}}{\up\seq\inj{\high}})$. The subtype coercion $\up$ sends
the security level of \texttt{false} from $\low$ to $\high$. The last step in
the body of \texttt{flip} is to apply the coercion \texttt{\proj{\low}{p}} to
the value $(\cccast{\false_{\low}}{\up\seq\inj{\high}})$, which errors because
$\high$ is greater than $\low$.

\subsection{Implicit Flow, NSU Checks, Unknown Security, and the Gradual Guarantee}
\label{sec:example2}

%% TODO define the precision relations in this section

The tension between information-flow security and the gradual guarantee arises
from an interaction between implicit flows and the use of no-sensitive-upgrade
checks to guard writes to mutable references. In brief, when \unk is allowed as
a runtime security label, some NSU checks have to conservatively trigger an
error to preserve noninterference, even though no error would occur if the label
was instead \high. But the gradual guarantee says that if a program with a
precise annotation runs without error, it should also run without error when
that annotation is changed to \unk.

In preparation to discuss this scenario in more detail, I first review the
no-sensitive-upgrade technique~\parencite{austin2009efficient} that protects against
illegal implicit flows through writes to mutable references. I then show how
allowing \unk as a runtime security label leads to a situation where a language
designer is forced to choose between noninterference and the gradual guarantee.
Finally, I show how this problem is resolved in the \Surface language by walking
back the choice of allowing \unk as a runtime security label.

The main idea of no-sensitive-upgrades is to prevent data leaks through the
mutable references by terminating execution whenever the program attempts to
modify a low-security heap cell in a high-security execution context. In
\Surface, NSU checks happen at runtime when type information is insufficient to
statically decide whether a heap-modifying operation is secure or not. Consider
the following well-typed program in \Surface:

\begin{lstlisting}[style=tt]
  let input : |$\Bool_{\unk}$| = user-input () in
  let a     = ref |\low| true in
  let _     = if input then a := false else a := true in
    publish (! a)
\end{lstlisting}

\noindent
The assignments to \texttt{a} in the two branches try to write different
low-security booleans into the cell at the address in \texttt{a}, depending on a
branch condition whose security level is statically unknown. However, at runtime
the \texttt{user-input} function returns a high-security boolean, so the branch
condition is actually high security, and if the writes were successful, the
program would leak information via an implicit flow. Fortunately, if we run this
program, it reduces to blame regardless of the input. The way NSU checking works
in \Surface is that a security level is associated with the current program
counter. At the point of every write that requires an NSU, the system projects
the program counter's security level to the level of the memory location, making
sure that the later is at least as high as the former. In the above example, the
NSU check fails because the program counter's security is $\high$ but the write
is to a $\low$ security location.

In \GSLRef \parencite{Toro:2018aa}, the dynamic enforcement of IFC through the
heap is also based on NSU checks. Consider the following pair of programs
adapted from Section 6.3 of their paper. The program on the left is derived from
the program on the right by replacing some of the {\high} annotations with the
unknown label \unk. Both variants of the program type check but the more precise
variant runs to completion while the less precise variant triggers an error,
thus violating the gradual guarantee. Let us examine their runtime behavior in
further detail.

\begin{multicols}{2}
  \small
  \noindent
  \redtext{\textbf{Less precise, more dynamic:}}
  %% \vspace{-10pt}
  \begin{lstlisting}[style=tt,basicstyle=\ttfamily\footnotesize]
    let x = user-input () in
    let y = ref |$\Bool_{\unk}$| |$\true_{\unk}$| in
    if x then (y := |$\false_{\high}$|) else ()
  \end{lstlisting}
  \columnbreak
  \bluetext{\textbf{More precise, more static:}}
  %% \vspace{-7pt}
  \begin{lstlisting}[style=tt,basicstyle=\ttfamily\footnotesize]
    let x = user-input () in
    let y = ref |$\Bool_{\high}$| |$\true_{\high}$| in
    if x then (y := |$\false_{\high}$|) else ()
  \end{lstlisting}
\end{multicols}

\noindent The program on the \bluetext{right} runs without error in \GSLRef
because, at the assignment on line 3, variable \texttt{y} references a memory
cell of \high security and the PC's security level is also \high, so the
assignment is allowed.

In contrast, when the program on the \redtext{left} is run with input
$\true_{\high}$, the assignment is conservatively rejected by the NSU check.
This is because \GSLRef considers \unk as corresponding to the interval $[\low,
  \high]$, and the lower bound of this interval is not greater than or equal to
the \high PC label. So we see that this more precise program (\bluetext{right})
runs successfully while the less precise one (\redtext{left}) errors in \GSLRef.

\begin{figure}[tbp]
  \raggedright
  \fbox{$\vdash M \sqsubseteq N$}
  {\small
  \begin{gather*}
    {\sqsubseteq}\textit{-const}~
    \inference{}{\vdash \const{k}{\ell} \sqsubseteq \const{k}{\ell}}
    \quad
    {\sqsubseteq}\textit{-var}~
    \inference{}{\vdash x \sqsubseteq x}
    \\[2ex]
    {\sqsubseteq}\textit{-lam}~
    \inference{g_1 \sqsubseteq g_2 & A_1 \sqsubseteq A_2 & \vdash N_1 \sqsubseteq N_2 }
              {\vdash \lam{g_1}{x}{A_1}{N_1}{\ell} \sqsubseteq \lam{g_2}{x}{A_2}{N_2}{\ell}}
    \;
    {\sqsubseteq}\textit{-app}~
    \inference{\vdash L_1 \sqsubseteq L_2 & \vdash M_1 \sqsubseteq M_2}
              {\vdash \app{L_1}{M_1}{p} \sqsubseteq \app{L_2}{M_2}{p}}
    \\[2ex]
    {\sqsubseteq}\textit{-if}~
    \inference{\vdash L_1 \sqsubseteq L_2 & \vdash M_1 \sqsubseteq M_2 & \vdash N_1 \sqsubseteq N_2}
              {\vdash \ifexp{L_1}{M_1}{N_1}{p} \sqsubseteq \ifexp{L_2}{M_2}{N_2}{p}}
    \\[2ex]
    {\sqsubseteq}\textit{-ann}~
    \inference{\vdash M_1 \sqsubseteq M_2 & A \sqsubseteq B}
              {\vdash \ann{M_1}{A}{p} \sqsubseteq \ann{M_2}{B}{p}}
    \\[2ex]
    {\sqsubseteq}\textit{-let}~
    \inference{\vdash M_1 \sqsubseteq M_2 & \vdash N_1 \sqsubseteq N_2}
              {\vdash \letexp{x}{M_1}{N_1} \sqsubseteq \letexp{x}{M_2}{N_2}}
    \\[2ex]
    {\sqsubseteq}\textit{-ref}~
    \inference{\vdash M_1 \sqsubseteq M_2}
              {\vdash \refexp{\ell}{M_1}{p} \sqsubseteq \refexp{\ell}{M_2}{p}}
    \quad
    {\sqsubseteq}\textit{-deref}~
    \inference{\vdash M_1 \sqsubseteq M_2}
              {\vdash \deref{M_1}{p} \sqsubseteq \deref{M_2}{p}}
    \\[2ex]
    {\sqsubseteq}\textit{-assign}~
    \inference{\vdash L_1 \sqsubseteq L_2 & \vdash M_1 \sqsubseteq M_2}
              {\vdash \assign{L_1}{M_1}{p} \sqsubseteq \assign{L_2}{M_2}{p}}
  \end{gather*}}
  \caption{Precision rules of \Surface}
  \label{fig:surface-precision}
\end{figure}

In \Surface, the \unk security label can be used in type annotations, as one
would expect of a gradually-typed language, but \unk is not allowed as a runtime
security label and therefore also not allowed as a label on program literals and
other introduction forms. I present the formal definition of the precision
relation in Figure~\ref{fig:surface-precision}. The precision relation takes the
form $\vdash M \sqsubseteq N$, where $N$ is the same \Surface program as $M$,
except that all type annotations in $N$ are at least as precise as those in $M$.
In rule ${\sqsubseteq}$\textit{-const} and rule ${\sqsubseteq}$\textit{-lam},
the $\ell$ on both sides is the same, because it denotes the security level of
the constant or the function. In rule ${\sqsubseteq}$\textit{-ref}, both sides
are annotated with the same $\ell$, because it is for the security level of the
newly created memory location.

The following adapts the above examples from \GSLRef to \Surface. The fully
static variant (\bluetext{down}) is nearly identical to its \GSLRef counterpart.
To obtain the less-precise program (\redtext{up}), we change the type annotation
on variable \texttt{y} to model the similar loss of precision in the \GSLRef
counterpart. We do not change the labels on the \texttt{ref} or \texttt{true} to
$\unk$ because that is not allowed in \Surface as we just mentioned.

\noindent
\redtext{\small\textbf{Less precise, more dynamic:}}
\begin{lstlisting}[style=tt,basicstyle=\ttfamily\footnotesize]
  let x = user-input () in
  let y : |$(\Refer{\Bool_{\unk}})_{\unk}$| = ref |\high $\true_{\high}$| in
    if x then (y := |$\false_{\high}$|) else ()
\end{lstlisting}
\noindent
\bluetext{\small\textbf{More precise, more static:}}
\begin{lstlisting}[style=tt,basicstyle=\ttfamily\footnotesize]
  let x = user-input () in
  let y : |$(\Refer{\Bool_{\high}})_{\high}$| = ref |\high $\true_{\high}$| in
    if x then (y := |$\false_{\high}$|) else ()
\end{lstlisting}

\noindent Branching on high-security input and assigning to a high-security
memory location should be allowed. Indeed, both variants reduce to the unit
value regardless of the input, thereby not violating the gradual guarantee. The
fully annotated version (\bluetext{down}) evaluates to unit without any
overhead from runtime checking.

In the less-precise program (\redtext{up}), $(\Refer{\Bool_{\unk}})_{\unk}$
replaces $(\Refer{\Bool_{\high}})_{\high}$. This change in type annotation means
that both the security level of the memory and the security of the reference
itself are statically unknown and should be checked at runtime. When executing
the program, at the assignment on line 3, an NSU check happens and the
assignment to high-security memory under high PC is allowed. As a result, the
less-precise program also evaluates successfully to unit.

One might worry that the less precise program has a heavy annotation burden.
However, as we mentioned, the default security label is \low so the programmer
does not have to label constants in \Surface. So we can remove the labels on
constants to obtain the following program, which also reduces successfully to
unit:
\begin{lstlisting}[style=tt]
  let x = user-input () in
  let y : |$(\Refer{\Bool_{\unk}})_{\unk}$| = ref |\high|true in
    if x then (y := false) else ()
\end{lstlisting}
\noindent The low-security \texttt{true} is classified as high security during
reference creation because the security level of the cell is \high (line 2).
Similarly, during assignment the \texttt{false} is also classified as high
security because the security level of the cell (line 3). Assigning to a
high-security memory cell is allowed under a high PC by the NSU check, so the
program evaluates successfully to unit.

One might think that requiring the programmer to annotate the reference creation
with \high (line 2) is still a burden and that \GSLRef is better in this regard.
However, while \GSLRef allows the unannotated version of this program to
compile, it errors during program execution. It is better to require the
programmer to annotate references during program development than to have the
programs compile but then fail during program execution, perhaps only detected
after the program is deployed.

\subsection{Type-Based Reasoning in \Surface}
\label{sec:example3}

Type-based reasoning in gradual IFC languages arises from two language design
choices: vigilance and type-guided classification. Vigilance gives us type-based
reasoning for explicit flows, while type-guided classification provides
type-based reasoning about implicit flows. In this section, I am going to show
that \Surface is both vigilant and performs typed-guided classification, so
\Surface enables type-based reasoning in the sense of \textcite{Toro:2018aa}.

\subsubsection{\Surface is Vigilant}

A language with casts is \textit{vigilant} if it checks whether all the casts
that are applied to the same value are consistent with each other, and triggers
an error if they are not.

\textcite{Toro:2018aa} present the following example to demonstrate how vigilance
is needed for type-based reasoning and free theorems in the sense of
\textcite{Wadler:1989fk}. The example involves casts from $\low$ (line 3, the label
annotation on $\key{5}_{\low}$) to $\high$ (line 1, the type annotation
$\Int_{\high}$ in the signature of \texttt{mix}) and then back to $\low$ via the
unknown security level $\unk$ (line 2, the nested type annotations $\Int_{\unk}$
and $\Int_{\low}$):

\begin{lstlisting}[style=tt]
  let mix : |$\Int_{\low}$| -> |\colorbox{White!80!Maroon}{$\Int_{\high}$}| -> |$\Int_{\low}$| =
    |$\lambda$| pub priv . if pub < (priv : |\colorbox{White!80!Purple}{$\Int_{\unk}$}| : |\colorbox{White!80!NavyBlue}{$\Int_{\low}$}|) then 1 else 2 in
  mix 1|$_{\low}$| |\colorbox{White!70!YellowGreen}{$\key{5}_{\low}$}|
\end{lstlisting}

\noindent The type signature of \texttt{mix} should guarantee the free theorem
that either (1) the result of \texttt{mix}, which is low security, never depends
on the high-security \texttt{priv} argument or (2) \texttt{mix} produces a
runtime error. In this case, the output of \texttt{mix} does depend on
\texttt{priv} via an implicit flow, so the free theorem says that an error
should be triggered at runtime. Let us focus on the three casts applied to
$\key{5}_{\low}$, where the first cast sends the security level from \low to
\high because of the type annotation on line 1, the second cast is an injection
due to the first type annotation on line 2, and the third cast is a projection
to \low due to the second type annotation on line 2:
\[
\cccast{
  \cccast{
    \cccast{\colorbox{White!70!YellowGreen}{$\key{5}_{\low}$}}{\colorbox{White!70!YellowGreen}{\low} \Rightarrow \colorbox{White!80!Maroon}{\high}}
  }{\colorbox{White!80!Maroon}{\high} \Rightarrow \colorbox{White!80!Purple}{\unk}}}
  {\colorbox{White!80!Purple}{\unk} \Rightarrow \colorbox{White!80!NavyBlue}{\low}}
\]
In \Surface, these casts produce the sequence of coercions:
$\colorbox{White!70!YellowGreen}{$\key{5}_{\low}$} \left\langle
\colorbox{White!80!Maroon}{\up} \seq \colorbox{White!80!Purple}{\inj{\high}}
\seq \colorbox{White!80!NavyBlue}{\proj{\low}{p}} \right\rangle$, which trigger
an error when $\high$ collides with $\low$, blaming label $\bl{p}$.

Similarly, the interval refinement mechanism of \GSLRef detects the conflict
between the intermediate cast to $\high$ and the final cast to $\low$.
Surprisingly, in GLIO and in systems prior to \GSLRef \parencite{Disney:2011fv,
  Fennell:2013ab}, the program runs successfully and produces $\key{1}_{\low}$
because they are forgetful~\parencite{Greenberg:2014aa} regarding the
intermediate cast of $\key{5}_{\low}$ to $\high$ and only check that
$\key{5}_{\low}$ can be cast to \low. Those systems still satisfy
noninterference, because the labels \textit{on values} track their security
similar to fully dynamic IFC. It is just that the security labels on
\textit{type annotations} will not trigger errors at runtime, even if they are
inconsistent.

\section{The Static and Dynamic Extremes of \Surface}
\label{sec:embedding}

Same as \GSLRef, the static extreme of \Surface is \SSLRef: all security labels
in types are statically known, and the type system alone enforces IFC.
