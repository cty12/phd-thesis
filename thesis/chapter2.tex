\chapter{Gradual Information-Flow Control (IFC) in \Surface}
\label{ch:examples}

In this chapter, we first define the gradual IFC surface language \Surface, by
presenting its syntax and type system in Section~\ref{sec:surface-def}. After
that, we put \Surface into action. We present example programs to demonstrate
how \Surface enables a gradual, smooth transition between static and dynamic
IFC, while supporting type-based reasoning and satisfying the gradual guarantee.
We review the basics of gradual IFC using \Surface programs in
Section~\ref{sec:example1}. In Section~\ref{sec:example2}, we show that the
tension between security and the gradual guarantee can be achieved by removing
\unk from the runtime security labels. In Section~\ref{sec:example3}, we
demonstrate that \Surface enables the same type-based reasoning capabilities as
\GSLRef. To conclude this chapter, we discuss the static and the dynamic
extremes of \Surface in Section~\ref{sec:embedding}. \Surface enables the
continuum of IFC enforcement between the static and dynamic extremes that it
embeds.

\section{The Gradual IFC Language \Surface}
\label{sec:surface-def}

We present the syntax and its supporting definitions in
Section~\ref{sec:surface-syntax}. We explain the type system for \Surface in
Section~\ref{sec:surface-typing}. Finally, we discuss the semantics of \Surface
by defining the \texttt{eval} function in Section~\ref{sec:surface-semantics}.

\subsection{Syntax of \Surface}
\label{sec:surface-syntax}

\begin{figure}[tbp]
\raggedright
  {\small
  \[
  \begin{array}{rcll}
    \text{specific security labels} & \ell & \in & \{ \low , \high \} \\
    \text{security labels}  & g    & ::= & \unk \MID \ell \\
    \text{base types}               & \iota     & ::= & \Unit \MID \Bool \\
    \text{raw types}                & T, S      & ::= & \iota \MID \Fun{A}{\gc}{B} \mid \Refer{(T_g)} \\
    \text{blame labels}         & \bl{p}, \bl{q}     &      & \\
    \text{types}                    & A, B      & ::= & T_g \\
    \text{terms}                & L , M , N & ::=  & x \MID \const{k}{\text{\hl{$\ell$}}} \MID \lam{g}{x}{A}{N}{\text{\hl{$\ell$}}} \MID \app{L}{M}{p} \\
    &                                       & \MID & \ifexp{L}{M}{N}{p} \MID \letexp{x}{M}{N} \\
    &                                       & \MID & \refexp{\text{\hl{$\ell$}}}{M}{p} \MID \deref{M}{p} \MID \assign{L}{M}{p} \MID \ann{M}{A}{p}
  \end{array}
  \]}
  \caption{Syntax of \Surface (highlighted security labels \hl{$\ell$} default to \low if omitted)}
  \label{fig:surface-syntax}
\end{figure}

We present the syntax of the gradual language \Surface in
Figure~\ref{fig:surface-syntax}. The figure also includes the definitions for
security labels, blame labels, and types in \Surface.

For simplicity, we use the security lattice
$\langle \{\high, \low\} , \preccurlyeq, \curlyvee , \curlywedge \rangle$, where
$\high$ is for private data and $\low$ is for publicly disclosable data. Of
course, any lattice of security labels could be used in place of low and high.
The ordering is standard: $\low \preccurlyeq \high$ and $\high \npreccurlyeq
\low$. So information is allowed to flow from public sources to private sinks
but not the other way around. We refer to $\{\high,\low\}$ as \emph{specific
security labels}.

Types in \Surface have security labels associated with them, for example,
$\Bool_{\high}$ is the type for booleans with high security, $\Unit_{\low}$ is
the type for the unit value with low security, and $\Bool_{\unk}$ is the type of
a boolean whose security level is unknown at compile time. We refer to
$\{\high,\low,\unk\}$ as \emph{security labels}.

Some terms in \Surface are annotated with an identifier called a blame label
(\bl{p}). When compiled to the intermediate representation, those terms generate
runtime checking (casts) that may fail. In case a check fails, it raises a cast
error, called \textit{blame}, that contains its blame label. In this way, the
programmer knows which cast is causing the problem and which part of the program
generates that cast.

The syntax of \Surface is similar to that of \GSLRef. The main syntactic
difference is that in \Surface, the security labels of literals and newly
created memory cells default to a specific label such as \low, while in \GSLRef
they default to a runtime unknown security level \unk.

\subsection{Type System of \Surface}
\label{sec:surface-typing}

\begin{figure}[tbp]
\raggedright
  \fbox{$\Gamma ; g \vdash M : A$}
  \begin{gather*}
  \small
    {\vdash}\mathit{var}~
    \inference{\Gamma \ni x : A}
              {\Gamma; g \vdash x : A}
    \quad
    {\vdash}\mathit{const}~
    \inference{k : \iota}
              {\Gamma; g \vdash \const{k}{\ell} : \iota_\ell}
    \\[1ex]
    {\vdash}\mathit{lam}~
    \inference{(\Gamma , x{:}A); g_2 \vdash N : B}
              {\Gamma; g_1 \vdash \lam{g_2}{x}{A}{N}{\ell} : (\Fun{A}{g_2}{B})_\ell}
    \\[1ex]
    {\vdash}\mathit{app}~
    \inference{\Gamma; g \vdash L : (\Fun{A}{g_2}{B})_{g_1} &
               \Gamma; g \vdash M : A' \\
               A' \lesssim A & g \precsim g_2 & g_1 \precsim g_2}
              {\Gamma; g \vdash \app{L}{M}{p} : \textit{stamp}\;B\;g_1}
    \\[1ex]
    {\vdash}\mathit{let}~
    \inference{\Gamma; g \vdash M : A \\
               (\Gamma , x{:}A) ; g \vdash N : B}
              {\Gamma; g \vdash \letexp{x}{M}{N} : B}
    \\[1ex]
    {\vdash}\mathit{if}~
    \inference{\Gamma; g_2 \vdash L : \Bool_{g_1} \\
               \Gamma; g_2 \lconsisjoin g_1 \vdash M : A &
               \Gamma; g_2 \lconsisjoin g_1 \vdash N : B \\
               A \consisjoin B = C}
              {\Gamma; g_2 \vdash \ifexp{L}{M}{N}{p} : \textit{stamp}\;C\;g_1}
    \\[1ex]
    {\vdash}\mathit{ref}~
    \inference{\Gamma; g_2 \vdash M : T_{g_1} \\
               T_{g_1} \lesssim T_\ell & \highlightblue{g_2 \precsim \ell}}
              {\Gamma; g_2 \vdash \refexp{\ell}{M}{p} : (\Refer{T_\ell})_{\low}}
    \quad
    {\vdash}\mathit{deref}~
    \inference{\Gamma; g_2 \vdash M : (\Refer{A})_{g_1}}
              {\Gamma; g_2 \vdash \deref{M}{p} : \textit{stamp}\;A\;g_1}
    \\[1ex]
    {\vdash}\mathit{assign}~
    \inference{\Gamma; g_2 \vdash L : (\Refer{T_{\hat{g}}})_{g_1} &
               \Gamma; g_2 \vdash M : A \\
               A \lesssim T_{\hat{g}} & \highlightblue{g_2 \precsim \hat{g}} & \highlightblue{g_1 \precsim \hat{g}}}
              {\Gamma; g_2 \vdash \assign{L}{M}{p} : \Unit_{\low}}
    \quad
    {\vdash}\mathit{ann}~
    \inference{\Gamma; g \vdash M : A' \\ A' \lesssim A}
              {\Gamma; g \vdash \ann{M}{A}{p} : A}
  \end{gather*}
  \caption{Typing rules of the surface language \Surface. Side conditions about the heap policy
  are \highlightblue{\text{highlighted}}}
  \label{fig:surface-typing-full}
\end{figure}

\subsection{Semantics of \Surface}
\label{sec:surface-semantics}

%% foreshadow the semantics by defining the eval function

\section{The Gradual Transition Between Static and Dynamic IFC in \Surface}
\label{sec:example1}

For simplicity, we use the security lattice $\langle \{\high, \low\}
, \preccurlyeq, \curlyvee , \curlywedge \rangle$, where $\high$ is for
private data and $\low$ is for publicly disclosable data. The ordering
is standard: $\low \preccurlyeq \high$ and
$\high \npreccurlyeq \low$. So information is allowed to flow from
public sources to private sinks but not the other way around.
We refer to $\{\high,\low\}$ as \emph{specific security labels}.

\section{Implicit Flow, NSU Checks, Unknown Security, and the Gradual Guarantee}
\label{sec:example2}

%% TODO define the precision relations here

\section{Type-Based Reasoning in \Surface}
\label{sec:example3}

\section{The Static and Dynamic Extremes of \Surface}
\label{sec:embedding}
