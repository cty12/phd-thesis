\chapter{Introduction}

\section{Programming Languages Are Useful in Enforcing Security Policies}

With the development of digital society, people are increasingly concerned about
the confidentiality of their personal data and the integrity of their online
assets. Increasingly relying on computing devices and the Internet in their
daily life, people fear that sensitive personal information, such as social
security numbers, medical records, bank account balances... may be revealed to
malicious third parties. People also worry that their digital photo albums,
signatures on online legal documents, spreadsheets in cloud storage... may be
tampered and manipulated by potential attackers.

Indeed, the fears are justified by recent news events. In 2018, the Cambridge
Analytica scandal hit the world headlines, where the data collected from 87
million social media users was misused without their consent
~\parencite{cadwalladr2018facebook,kitchgaessner2017cambridge,gonzalez2019global,hinds2020wouldn}.
In the healthcare sector, from 2005 to 2019, 249.09 million individuals were
affected by data breaches that caused exposure of sensitive medical
data~\parencite{seh2020healthcare}. Researchers have found ways to tamper the
analytics APIs~\parencite{pfeffer2018tampering} and damage the integrity of
metadata, such as the numbers of likes, follows, and views, of major social
media platforms~\parencite{paquet2017can}. To deal with the security and privacy
challenges of the increasingly digitalized world, the European Union introduced
the General Data Protection Regulation (GDPR) to reform and regulate the
collection and processing of personal data. However, studies show that business
entities experience challenges in complying with GDPR or auditing for
compliance~\parencite{smirnova2024understanding}, particularly small-to-medium
enterprises~\parencite{sirur2018we,freitas2018gdpr,harting2021impacts}.

\begin{figure}[tbp]
  \small
  \begin{align*}
    \langle \mathit{RECORD} \rangle ::= & {\color{green} \textbf{\{FirstName=}} \langle \mathit{ID} \rangle {\color{green} \textbf{;}} \\
                               & \enspace {\color{green} \textbf{LastName=}} \langle \mathit{ID} \rangle {\color{green} \textbf{;}} \\
                               & \enspace {\color{green} \textbf{SSN=}} \langle \mathit{SSN} \rangle {\color{green} \textbf{\}}} \\
    \langle \mathit{ID} \rangle     ::= & w , w \in \{ {\color{green} \textbf{A}}, ... {\color{green} \textbf{Z}}, {\color{green} \textbf{a}}, ... {\color{green} \textbf{z}} \}^{+} \\
    \langle \textit{SSN} \rangle    ::= & \langle D \rangle \langle D \rangle \langle D \rangle {\color{green} \textbf{-}}
                                 \langle D \rangle \langle D \rangle {\color{green} \textbf{-}}
                                 \langle D \rangle \langle D \rangle \langle D \rangle \langle D \rangle \\
    \langle D \rangle      ::= & d , d \in \{ {\color{red} \textbf{0}}, ... {\color{red} \textbf{9}} \}
  \end{align*}
  \caption{The user input grammar for a hypothetical application}
  \label{fig:grammar}
\end{figure}

From a technical perspective, ensuring the security and privacy of personal data
typically involves tracking and checking the flow of information. To ensure
confidentiality, data must not flow to inappropriate destinations, so that
sensitive personal information is not revealed; dually, to ensure integrity,
data must not flow from inappropriate sources, so that valuable digital assets
are not corrupted~\cite{sabelfeld2003language,biba1977integrity}. In practice,
such enforcement of the flow of information is often difficult to implement.
Take confidentially for example, software applications accept user input where
selected fields are sensitive, whose confidentiality is required during their
entire life cycle including both parsing and data processing. To rule out
information leaks, neither the sensitive fields, nor any data that depends on
those fields, is allowed to be revealed to a low-privilege observer. Consider a
web application that receives three fields from its user: \Circled{1} first name
\Circled{2} last name \Circled{3} social security number, the grammar of which
is defined in Figure~\ref{fig:grammar}, where terminals are divided into
low-security and high-security. The digits $d$ for social security number, being
confidential to users of the web application, are of high-security, so they are
marked {\color{red} red}, while other terminals, such as the keys of the record
and the strings $w$ for first name / last name, being safe to disclose, are all
of low-security, marked in {\color{green} green}. Consider the following user
input:

\begin{lstlisting}[numbers=none,xleftmargin=0.1\textwidth]
{FirstName=Mad;LastName=Hatter;SSN=012-34-5678}
\end{lstlisting}

\noindent It is tedious for the developer of this imaginary web application to track the
security level of data and check for information leaks. Software developers tend
to focus more on functionality in order to meet the tight software release
schedule and budget, thus software security usually only comes as an
afterthought
~\parencite{assal2018security,sharma2017aspects,steward2012software}.
Retrofitting security-related code often requires extensive modification to an
existing code-base and it relies on the programmers' skills and experience to
decide when and where such code should be placed. Furthermore, such modification
is error-prone: one single missing check could undermine the security of the
entire application.

\begin{figure*}[tbp]
  \small
  \center
\begin{tikzpicture}[scale=0.8]
\tikzset{level distance=50pt}
\Tree [
  .{ $\langle \mathit{RECORD} \rangle$ }
  {\color{green} \textbf{\{FirstName=}}
  [ .{ $\langle \mathit{ID} \rangle$ } {\color{green} \textbf{Mad}} ]
  {\color{green} \textbf{;LastName=}}
  [ .{ $\langle \mathit{ID} \rangle$ } {\color{green} \textbf{Hatter}} ]
  {\color{green} \textbf{;SSN=}}
                       [ .{ $\langle \mathit{SSN} \rangle$ }
                         [ .{ $\langle D \rangle$ } {\color{red} \textbf{0}} ]
                         [ .{ $\langle D \rangle$ } {\color{red} \textbf{1}} ]
                         [ .{ $\langle D \rangle$ } {\color{red} \textbf{2}} ]
                         {\color{green} \textbf{-}}
                                [ .{ $\langle D \rangle$ } {\color{red} \textbf{3}} ]
                                [ .{ $\langle D \rangle$ } {\color{red} \textbf{4}} ]
                                {\color{green} \textbf{-}}
                                       [ .{ $\langle D \rangle$ } {\color{red} \textbf{5}} ]
                                       [ .{ $\langle D \rangle$ } {\color{red} \textbf{6}} ]
                                       [ .{ $\langle D \rangle$ } {\color{red} \textbf{7}} ]
                                       [ .{ $\langle D \rangle$ } {\color{red} \textbf{8}} ] ]
                       {\color{green} \textbf{\}}}
]
\end{tikzpicture}
\caption{The parse tree generated from the example user input.
  All terminals are represented as labeled values:
  the {\color{red} red} ones, such as the digits of SSN,
  are of high-security, while the {\color{green} green} ones, such as the keys
  of the record and first name / last name, are of low-security.}
\label{fig:parsetree}
\end{figure*}

Alternatively, the author of the web application could implement a parser for
the grammar in Figure~\ref{fig:grammar} in a programming language that enforces
information-flow security. Each terminal in the grammar would be labeled with a
security level and the programming language, instead of some ad-hoc checks
implemented by the programmer of the web application, would guarantee that the
high-security information is only present in those parts of the output parse
tree that are marked as high-security. For example, according to the grammar in
Figure~\ref{fig:grammar}, the example user input string is parsed into the parse
tree in Figure~\ref{fig:parsetree}, where the terminal nodes that represent
digits of the social security number are of {\color{red} high-security}, while
the terminals that compose the rest of the input string are of {\color{green}
  low-security}. The confidentiality of SSN is guaranteed during data processing
since the programming language enforces noninterference. When the web
application interacts with the outside world, such as making a foreign function
interface (FFI) call or storing into a database, the conceptual language should
encrypt whatever values labeled as high security before they are passed into a
foreign routine. The programming language-based approach of information-flow
security~\parencite{sabelfeld2003language} alleviates the security burden of
software development, because it forms an abstraction over the flows of
information and decouples security from the functionality of a software
application.


\section{Traditional Mechanisms of Programming Language-Based
         Information-Flow Control: Static, Dynamic, Hybrid}

Information-flow control (IFC) ensures that information transfers within a
program adhere to a security policy, for example, by preventing high-security
data from flowing to a low-security channel. This adherence can be enforced
statically using a type
system~\parencite{volpano1996sound,Myers:1997aa,myers1999jflow}, or dynamically
using runtime
monitoring~\parencite{Askarov:2009vq,austin2009efficient,Devriese:2010up,stefan2011flexible,Austin:2017uh,Xiang:2021ub},
or using static analysis to pre-compute information that facilitates runtime
monitoring
~\parencite{le2005monitoring,le2007automaton,Chandra:2007we,Shroff:2007tg,russo2010dynamic,moore2011static}.
The static and dynamic approaches have complementary strengths and weaknesses;
the dynamic approach requires less effort from the programmer while the static
approach provides stronger guarantees and less runtime overhead.
Recently,~\textcite{Buiras:2015aa} propose a hybrid technique that offers the
programmer control over the regions within a program where IFC is enforced
statically versus dynamically, so that the programmer can benefit from the
static and dynamic approaches depending on their most appropriate application
scenarios.

\textbf{Static IFC in programming languages} The interest in enforcing
confidentiality and regulating the flow of information in a computer program
arises with its defense applications in the 1970s \autocite{bell1976secure}.
\textcite{denning1976lattice} builds a information flow model using a lattice of
security labels and \textcite{denning1977certification} discuss the
certification technique in further detail, with a proof that a certified program
will not give away confidential input from non-confidential output.
\textcite{volpano1996sound} propose a typed-based approach to enforcing
information flow, by defining a type system for an imperative programming
language and proving its security with a type soundness proof. This idea is
further developed by \textcite{zdancewic2002programming}. Such a protection
scales well since type checking is \textit{compositional}
\parencite{sabelfeld2003language}. There are projects that apply similar
techniques but to other languages such as bytecode intermediate languages
\autocite{barthe2005non}, object-oriented languages \autocite{amtoft2006logic},
and reactive programming languages \autocite{bohannon2009reactive}. Although the
aforementioned languages are mostly theoretical, efforts have also been made to
integrate information flow control into widely-used existing languages such as
Jif for Java \autocite{myers1999jflow} and Flow Caml for OCaml
\autocite{pottier2002information, simonet2003flow}.

\textbf{Dynamic IFC in programming languages}
\textcite{li2006encoding,LI20101974} add flow control to Haskell by utilizing
existing language features, specifically arrow and typeclass, to implement
checks. \textcite{stefan2011flexible,stefan2012flexible,STEFAN:2017ta} design a
Haskell library called LIO; inspired by IFC operating systems
~\parencite{efstathopoulos2005labels,zeldovich2011making,krohn2007information,vandebogart2007labels},
LIO takes a coarse-grained, floating-label approach that employs a labeled IO
monad to keep track of the current privilege level, which restricts both the
observability and the security effect. \textcite{austin2009efficient} consider
IFC for Javascript and propose a purely dynamic approach called
\textit{no-sensitive-upgrade} checking to handle implicit flows through the
heap, by terminating the execution whenever a program attempts to modify a
low-security memory location under a high-security context.
\textcite{austin2010permissive} study a sound yet more flexible enforcement
strategy called \textit{permissive-upgrade}, which allows more programs to run
to completion. \textcite{austin2012multiple,Austin:2017uh} propose
\textit{faceted values}, another approach to dynamically handle implicit flows
by simulating multi-execution in a single process, which, unlike
no-sensitive-upgrade and permissive-upgrade, avoids conservative monitor
failures.

\textbf{Dynamic IFC with static pre-processing} Researchers have also explored
facilitating runtime IFC with static analysis. \textcite{le2005monitoring}
explore a hybrid IFC monitor for sequential programs that combines runtime IFC
with a static analysis that gathers information about the non-executed branches.
This hybrid IFC accepts programs that are conservatively rejected by fully
static IFC. They further show that it is possible to alter the behavior of
executions that may be unsafe by resetting output values using the information
from their hybrid analysis to reclaim confidentiality.
\textcite{le2007automaton} extends this hybrid IFC approach to concurrent
programs and prove noninterference for any execution. \textcite{Shroff:2007tg}
build a runtime monitor augmented with a pre-computed fixed point of
dependencies. Similar to \textcite{le2005monitoring}, they observe that this
hybrid technique is less conservatively than a fully static system. They also
show that their hybrid monitor is able to support user-defined policy, so that
different policies can be applied to the same program. \textcite{Chandra:2007we}
implement a hybrid monitor for the Java virtual machine. Their implementation
add IFC annotations to a executable file using a static analysis. The runtime
monitor then uses those annotations to update the labels of variables in
alternative execution paths to enforce IFC, while maintaining
backward-compatibility with existing Java class files.
\textcite{russo2010dynamic} study dynamic IFC in a flow-sensitive setting. They
utilize a static analysis that detects variables in untaken branches whose
security must be upgraded at runtime in order to prevent illegal implicit flows
through the heap. \textcite{moore2011static} improve the efficiency of the
hybrid monitoring of \textcite{russo2010dynamic} by selectively tracking
variables and incorporating memory abstractions. This line of research that
augments dynamic IFC with static analysis achieves goals that are hard to
accomplish by using fully static or dynamic IFC alone; different from gradual
typing, papers in this category do not aim at offering programmer the control
over statically versus dynamically enforced regions in one single program.

\textbf{Programmer-controlled hybrid IFC} Similar to gradual security-typed
languages and different from dynamic IFC with static pre-processing, Hybrid LIO
(HLIO)~\cite{Buiras:2015aa} supports the choice of static or dynamic IFC in
different regions of a single program. By default, the checking is static, but a
programmer can insert a \texttt{defer} clause to say that the security
constraints should be checked at runtime. There are two major differences
between HLIO and a gradual security-typed programming language. In HLIO, the
developer has to embed explicit \texttt{defer} into the program, while in a
gradual language, the switch between static and dynamic is directed by types,
with no \texttt{defer} or explicit casts needed. Moreover, there is no theorem
about adding and removing \texttt{defer} in HLIO, while in a gradual language
the gradual guarantee relates the runtime behavior of programs that differ only
in the precision of type annotations.

%% In gradual security-typed languages,
%% the switch between static and dynamic is directed by types, so unlike in HLIO,
%% the developer does not need to embed explicit casts or \texttt{defer} into the
%% program. Moreover, the gradual guarantee relates the runtime behavior of
%% programs that differ in the precision of type annotations, but there is no
%% comparable theorem about adding and removing \texttt{defer} in HLIO.

\section{The Tension Between Gradual Typing and Information-Flow Control}

Taking inspiration from gradual typing~\parencite{Siek:2006bh,Siek:2007qy},
researchers have explored new ways to give programmers control over which parts
of the program are secured statically versus dynamically, directed by
\textit{type annotations}.
%
In general, gradually typed languages support the seamless transition between
static and dynamic enforcement through the \textit{precision} of type
annotations. The programmer can choose when it is appropriate to increase the
precision of the type annotations and put in the effort to pass the static
checks and when it is appropriate to reduce the precision of type annotations,
deferring the enforcement to runtime.

The main challenge in the design of gradually typed languages is controlling the
flow of values (and information) between the static and dynamic regions of code,
which is accomplished using runtime casts. Typically source programs are
compiled to an intermediate language, called a cast calculus, that includes
explicit syntax for runtime casts. \textcite{Disney:2011fv} design a cast
calculus with IFC for a pure lambda calculus and prove noninterference.
\textcite{Fennell:2013ab} design a cast calculus named ML-GS with mutable
references using the no-sensitive-upgrade (NSU) runtime checks of
\textcite{austin2009efficient}. \textcite{Fennell:2015aa} design a cast calculus
for an imperative, object-oriented language.

\begin{table}[tbp]
  \footnotesize
  \centering
  \caption{Proposed sources of tension between security and the gradual guarantee}
  \begin{tabularx}{\textwidth}{X|c|c|c|c|c}
  \toprule
  \thead{Language} & \thead{Security \\ (noninterference)} & \thead{Gradual\\Guarantee} &
  \thead{Type-guided \\ classification} & \thead{NSU \\ checking} & \thead{Runtime \\ security labels} \\
  \hline
  \GSLRef    & \tikzmark{a}{\yes}  & \cellcolor{Red!10} \tikzmark{b}{\no} & \yes  & \yes & $\{ \low, \high, \unk \}$ \\[1ex]
  \hline
  GLIO      & \yes & \cellcolor{Green!10} \tikzmark{c}{\yes} & \tikzmark{d}{\no}  & \yes & $\{ \low, \high \}$ \\[1ex]
  \hline
  \WHILEG & \yes & \cellcolor{Green!10} \tikzmark{e}{\yes} & \yes   & \tikzmark{f}{\no} & $\{ \low, \high, \unk \}$ \\[1ex]
  \hline
  \rowcolor{highlight}
  \Surface~{\scriptsize (this dissertation)} & \yes & \cellcolor{Green!10} \tikzmark{g}{\yes} & \yes & \yes & \tikzmark{h}{$\{ \low, \high \}$} \\[1ex]
  \bottomrule
  \end{tabularx}
\begin{tikzpicture}[overlay, remember picture, yshift=.25\baselineskip, shorten >=.5pt, shorten <=.5pt]
  \draw[dashed,thick] (a) to [bend right=15] (b);
  \draw[dashed,thick] (c) to [bend right=15] (d);
  \draw[dashed,thick] (e) to [bend right=10] (f);
  \draw[thick]        (g) to [bend right=8 ] (h);
\end{tikzpicture}
  \label{tab:cc-features}
\end{table}

The main property of gradually typed languages is the \textit{gradual
  guarantee}~\cite{Siek:2015ac}, which states that removing type annotations
should not change the runtime behavior. Adding type annotations should also
result in the same behavior except that it may introduce more trapped errors
because those new type annotations may contain mistakes. Since the formulation
of the gradual guarantee as a criterion for gradually typed
languages~\cite{Siek:2015ac}, researchers have explored the feasibility of
satisfying both the gradual guarantee and noninterference.
\textcite{Toro:2018aa} identify a tension between the gradual guarantee and
security enforcement. They analyze the semantics of runtime casts through the
lens of Abstracting Gradual Typing~\parencite{Garcia:2016aa} and propose a
type-driven semantics for gradual security. However, \textcite{Toro:2018aa}
discover counterexamples to the gradual guarantee in the \GSLRef language. They
conjecture that it is not possible to enforce noninterference and satisfy the
gradual guarantee at the same time.

\textcite{Amorim:2020aa} conjecture one possible source of the tension: the
\textit{type-guided classification} performed in
\GSLRef~\parencite{Toro:2018aa}. They propose a new gradually typed language,
GLIO, which sacrifices type-guided classification. They prove that GLIO
satisfies both noninterference and the gradual guarantee using a denotational
semantics.
%
\textcite{bichhawat2021gradual} conjecture that \textit{NSU checking} could be
another possible source of the tension. As an alternative, they propose a hybrid
approach that leverages static analysis ahead of program execution to determine
the write effects in untaken branches. They study a simple imperative language
with first-order stores and prove both noninterference and the gradual
guarantee.

Surprisingly, contrary to the prior work, I am going to show in this
dissertation that one does not have to give up on type-guided classification or
NSU checking to resolve the tension between noninterference and the gradual
guarantee. Instead, the real source of the tension is that \GSLRef allows \unk
as a \textit{runtime} security label. By walking back this usual design choice,
I am going to present a gradual security-typed programming language \Surface and
prove that \Surface satisfies both noninterference and the gradual guarantee
without any sacrifices.

\section{Thesis Statement}

\section{Contributions and Outline}
